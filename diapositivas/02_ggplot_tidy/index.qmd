---
title: Analítica de Datos
author: Carlos Cardona Andrade
subtitle: ggplot y tidyverse
execute:
  freeze: auto
  echo: true
  fig-width: 6
  fig-height: 5
format:
  revealjs: 
   theme: ../slides.scss
   header-includes: |
      <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"/>
   slide-number: true
   show-slide-number: all
   transition: fade
   progress: true
   multiplex: false
   scrollable: false
   preview-links: false
   hide-inactive-cursor: true
   highlight-style: printing
   pause: true
---
     
```{r}
#| eval: true
#| echo: false
library(knitr)
library(forcats)
library(patchwork)
library(lubridate)
library(cowplot)
library(tidyverse)
library(kableExtra)

```


## Plan para hoy

1. [tidy data](#tidy)

2. [tibble vs. data frame](#tibble)

3. [El operador pipe](#pipe)

4. [ggplot](#ggplot)


5. [dplyr](#dplyr)

6. [Modificando un data frame](#dataframe)


# tidy data {#tidy}

## ¿Qué es "tidy" data? {.medium}

- Las 3 características claves son:
    1. Cada variable forma una columna.
    2. Cada observación forma una fila.
    3. Cada tipo de unidad de observación forma una tabla.
    
![](img/tidydata.png){width=250}

## ¿Por qué tidy data? {.medium}

- Un conjunto de datos en forma *tidy*[^1] facilita la selección de variables, la agrupación, el resumen y la visualización

. . .

- Algunas herramientas y paquetes en el `tidyverse` como dplyr o ggplot2 requieren que los datos se organicen de esa manera

. . .

El problema: la mayoría de los datos que obtengan no estarán “ordenados” desde el principio $\rightarrow$ tendrán que remodelarlos


[^1]: Algunos recursos si quieren profundizar en este tema son el paquete [tidyr](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html){target="_blank"} y el [paper original](https://vita.had.co.nz/papers/tidy-data.pdf){target="_blank"} (Hadley Wickham, 2014 JSS).

    
    
## Los paquetes de hoy {.medium}

- Como vimos la clase pasada, el paquete `tidyverse` es fundamental para la visualización y transformación de datos.

```{r}
#| warning: true
# install.packages("tidyverse") En caso de no tenerlo aún instalado!
library(tidyverse)
```

. . . 

- `gapminder` es otro paquete que usaremos en la clase de hoy:

```{r}
#| eval: false
install.packages("gapminder")
library(gapminder)
```


    
## El conjunto de datos gapminder {.medium}

Como vamos a graficar el conjunto de datos de [gapminder](https://github.com/jennybc/gapminder){target="_blank"}, es útil saber que contiene datos de panel sobre la esperanza de vida, el tamaño de la población y el PIB per cápita para 142 países desde la década de 1950.

```{r}
#| echo: true
library(gapminder)
gapminder
```
    
## gapminder -- dimensiones {.medium}

-   Número de filas:

```{r}
nrow(gapminder)
```

. . .

-   Número de columnas:

```{r}
ncol(gapminder)
```

## gapminder -- primer vistazo {.medium}

Las siguientes 3 funciones son útiles para evaluar el contenido de una base de datos.

::: panel-tabset
## `glimpse()`

```{r}
glimpse(gapminder)
```

## `names()`

```{r}
names(gapminder)
```

## `head()`

```{r}
head(gapminder)
```
:::

# tibble vs. data frame {#tibble}

## tibble vs. data frame {.medium}

-   Un [tibble]{.marker-hl}[^2] es una estructura de datos basada en un data frame con algunas mejores que facilitan su uso

::: incremental
-   [Todos los tibbles son data frames, pero no todos los data frames son tibbles]{.hl .hl-dred}
-   Dos diferencias principales entre un tibble y un data frame:
    -   Impresión
    -   Selección más estricta
:::

[^2]: El [capítulo 10](https://r4ds.had.co.nz/tibbles.html){target="_blank"} de la primera edición de R4DS es una buena referencia para profundizar en el tema.

## Impresión {.medium}

::: panel-tabset
## `tibble`

Muestra las 10 primeras filas y todas las columnas que quepan en la pantalla. Adicionalmente, muestra el tipo de variable para cada columna.

```{r}
gapminder
```

## `data.frame`

Intentará mostrar todos los datos, o fracasará intentando si el conjunto de datos es muy grande

```{r}
cars
```
:::

## Selección más estricta {.medium}

::: panel-tabset
## `tibble`

Warning + `NULL` si no encuentra la variable.

```{r}
#| warning: true
gapminder$apple
```

## `data.frame`

Sólo `NULL` si no encuentra la variable.

```{r}
#| label: data-frame-subset

cars$apple
```
:::

# El operador pipe {#pipe}

## El operador pipe en acción {.medium}

- El operador **pipe** (`|>`) es una herramienta para pasar información de un proceso al otro

- Las dos siguientes líneas de código hacen lo mismo:

```{r}
#| eval: false
gapminder |> filter(year == 2007) |>  group_by(continent)  |> summarize(mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)) |> arrange(desc(mean_gpdpercapita))
arrange(summarize(group_by(filter(gapminder, year == 2007), continent), mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)), desc(mean_gpdpercapita))
```

. . . 

- La primera línea se lee de izquierda a derecha, exactamente como uno pensaría los procesos

- La segunda línea invierte totalmente este orden lógico (¡la operación final viene primero!)


## El operador pipe en acción {.smaller}

```{r}
#| label: pipe-1

gapminder # <1>
```

1.  Toma el data frame gapminder

## El operador pipe en acción {.smaller}

```{r}
#| label: pipe-2

gapminder |>               # <1>
  filter(year == 2007)     # <2>
```

1.  Toma el data frame gapminder,
2.  **y luego** selecciona las observaciones en el año 2007

## El operador pipe en acción {.smaller}

```{r}
#| label: pipe-3

gapminder |>                 # <1>
  filter(year == 2002) |>    # <2>
  group_by(continent)        # <3>
```

1.  Toma el data frame gapminder,
2.  **y luego** selecciona las observaciones en el año 2002,
3.  **y luego** agrupa por continente

## El operador pipe en acción {.smaller}

```{r}
#| label: pipe-4

gapminder |>                # <1>
  filter(year == 2007) |>   # <2>
  group_by(continent)  |>   # <3>
  summarize(mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)) # <4>
```

1.  Toma el data frame gapminder,
2.  **y luego** selecciona las observaciones en el año 2007,
3.  **y luego** agrupa por continente,
4.  **y luego** calcula el GDP per cápita promedio para cada continente

## El operador pipe en acción {.smaller}

```{r}
#| label: pipe-5

gapminder |>                 # <1>
  filter(year == 2007) |>    # <2>
  group_by(continent)  |>    # <3>
  summarize(mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)) |> # <4>
  arrange(desc(mean_gpdpercapita)) # <5>
```

1.  Toma el data frame gapminder,
2.  **y luego** selecciona las observaciones en el año 2007,
3.  **y luego** agrupa por continente,
4.  **y luego** calcula el GDP per cápita para cada continente,
5.  **y luego** organiza de manera descendente basado en el GDP per cápita promedio.

## Algunas consideraciones sobre `|>` {.medium}


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
gapminder |> filter(year == 2007) |>  group_by(continent)  |> summarize(mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)) |> arrange(desc(mean_gpdpercapita))
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
gapminder |>                 
  filter(year == 2007) |>    
  group_by(continent)  |>    
  summarize(mean_gpdpercapita = mean(gdpPercap, na.rm = TRUE)) |> 
  arrange(desc(mean_gpdpercapita)) 
```
:::
:::


- Usar espacio vertical no cuesta nada y genera un código mucho más legible y fácil de escribir que amontonar cosas horizontalmente

. . . 

- Otra manera de denotar el pipe operator es `%>%`. Hay diferencias entre ambos pero van más allá del propósito del curso

- Revisen el post [|> vs. %>%](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/){target="_blank"} si quieren profundizar en el tema 



# ggplot {#ggplot}

<center>
![](img/ggplot-logo.png){width=250}
</center>

## ggplot2 {.medium}

Es el principal paquete para visualizar datos en `tidyverse`


::: columns
::: {.column width="50%"}
[ggplot2.tidyverse.org](https://ggplot2.tidyverse.org/){target="_blank"}

```{=html}
<iframe width=600 height=375 src="https://ggplot2.tidyverse.org/" title="dplyr home page"></iframe>
```
:::

::: {.column width="50%"}
[Cheat sheet](https://rstudio.github.io/cheatsheets/html/data-visualization.html){target="_blank"}

[![](img/ggplot-cheat-sheet.png)](https://rstudio.github.io/cheatsheets/html/data-visualization.html){target="_blank"}
:::
:::

## El paquete ggplot {.medium}
```{r, fig.width = 4, fig.asp = 0.45} 
#| echo: false
#| fig.align: 'center'
aes_pos <- ggdraw() + 
  geom_segment(data = data.frame(x = c(0, 0.5),
                                 xend = c(1, 0.5),
                                 y = c(0.5, 0),
                                 yend = c(0.5, 1)),
               aes(x = x, y = y, xend = xend, yend = yend),
               arrow = arrow(length = grid::unit(12, "pt")), size = .75) +
  draw_text("y", .5, 1, size = 12, vjust = 1, hjust = 2.5) +
  draw_text("x", 1, .5, size = 12, vjust = 2, hjust = 1) + 
  coord_cartesian(xlim = c(-.2, 1.2), ylim = c(-.2, 1.2))

aes_color <- ggdraw() +
  geom_tile(data = data.frame(x = 0.15 + .2333*(0:3)),
            aes(x, y = .5, fill = factor(x)), width = .2, height = .6) 
aes_shape <- ggdraw() +
  geom_point(data = data.frame(x = (.5 + 0:3)/4),
             aes(x, y = .5, shape = factor(x)), size = 8, fill = "grey80") +
  scale_shape_manual(values = 21:24)

aes_size <- ggdraw() +
  geom_point(data = data.frame(x = (.5 + 0:3)/4),
             aes(x, y = .5, size = factor(x)), shape = 21, fill = "grey80") +
  scale_size_manual(values = c(2, 5, 8, 11))

aes_lwd <- ggdraw() +
  geom_segment(data = data.frame(x = rep(0.05, 4),
                                 xend = rep(0.95, 4),
                                 y = (1.5 + 0:3)/6,
                                 yend = (1.5 + 0:3)/6,
                                 size = 4:1),
               aes(x = x, y = y, xend = xend, yend = yend, size = size)) +
  scale_size_identity()

aes_ltp <- ggdraw() +
  geom_segment(data = data.frame(x = rep(0.05, 4),
                                 xend = rep(0.95, 4),
                                 y = (1.5 + 0:3)/6,
                                 yend = (1.5 + 0:3)/6,
                                 linetype = 4:1),
               aes(x = x, y = y, xend = xend, yend = yend, linetype = linetype), size = 1) +
  scale_linetype_identity()


plot_grid(aes_pos, aes_shape, aes_size,
          aes_color, aes_lwd, aes_ltp,
          ncol = 3,
          labels = c("position", "shape", "size", "color", "line width", "line type"),
          label_x = 0.05, label_y = 0.95, hjust = 0, vjust = 1)
```

El paquete ggplot2 creado por [Hadley Wickham](http://hadley.nz/){target="_blank"} es uno de los paquetes más populares de todo el mundo R. 
  
  - Está construido sobre una teoría de visualización profunda: i.e. [*The Grammar of Graphics*](https://www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448){target="_blank"} de Leland Wilkinson

## Elements of ggplot2 {.medium}

Hay mucho que decir sobre la implementación de este enfoque de "gramática de gráficos" en ggplot2, pero los tres elementos clave son:

1. La gráfica está conectada a las variables ("los datos") a través de varios [mapeos estéticos]{.hl .hl-blue} (aestethic mappings).

2. Una vez el mapeo estético está definido, ustedes pueden representar sus datos en diferentes maneras al elegir diferentes [objetos geométricos]{.hl .hl-blue} (i.e. "geoms" como puntos, líneas o barras).

3. Los gráficos se contruyen por [capas]{.hl .hl-blue}.

</br>

Esto es un poco abstracto. Repasemos cada elemento uno por uno con algunos gráficos reales.


    
## 1. Mapeo estético {.medium}

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 10
#| fig-height: 5
#| dpi: 320
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) + 
  geom_point()
```


## 1. Mapeo estético {.medium}

``` {r}
#| eval: false
#| echo: true
#| code-line-numbers: "1"
ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) + 
  geom_point()
```

Concentrémonos en la primera línea que contiene el llamado a la función `ggplot()`. La función acepta varios argumentos incluyendo:

  - los datos que estamos usando (i.e. `data = gapminder`).
  - el mapeo estético (i.e. `mapping = aes(x = gdpPercap, y = lifeExp)`).


El mapeo estético acá es simple: sólo define un eje x (gdpPercap) y un eje y (lifeExp).


## 1. Mapeo estético - Tipos {.medium}

Sin embargo, para tener una idea del poder y la flexibilidad que conlleva este enfoque, consideremos lo que sucede si agregamos alguna de las siguientes estética a la línea de la función...

![](img/aesthetics.png){fig-align="center" width=800 height=400}


## 1. Mapeo estético {.medium}

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 8
#| fig-height: 4
#| dpi: 320
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp, size = pop, color = continent)) + 
  geom_point(alpha = 0.3) ## "alpha" controls transparency. Takes a value between 0 and 1.
```


Noten que borramos la parte "mapping =" al llamar la función. La mayoría de la gente sólo empieza con "aes(...)", ya que `ggplot2` sabe el orden de los argumentos.


## 1. Mapeo estético {.medium}

También podemos especificar el mapeo estético en la línea del objeto geométrico que queremos.


```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 10
#| fig-height: 5
#| dpi: 320
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + ## Applicable to all geoms
  geom_point(aes(size = pop, color = continent), alpha = 0.3) ## Applicable to this geom only
```

## 1. Mapeo estético {.medium}

¿Qué salió mal aquí?

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 8
#| fig-height: 4
#| dpi: 320
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(aes(size = "big", col="blue"), alpha = 0.3)
```

. . .

<br/> **Respuesta: **Las características estéticas están asociadas a variables, no a descripciones!


## 1. Mapeo estético {.medium}

<br>

::::: {.columns}

:::: {.column width="50%"}
```{r}
#| echo: true
#| fig.align: 'center'
#| fig-height: 5
#| dpi: 320
#| code-line-numbers: "2"
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(aes(col="blue"), alpha = 0.3)
```

::::


:::: {.column width="50%"}
```{r}
#| echo: true
#| fig.align: 'center'
#| fig-height: 5
#| dpi: 320
#| code-line-numbers: "2"
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + 
  geom_point(color = "blue", alpha = 0.3)
```
::::
::::

## 1. Mapeo estético {.medium}

En este punto, en lugar de repetir la misma primera línea del código, es más conveniente definir un gráfico intermedio que podamos reutilizar.

```{r}
#| echo: true
#| fig.align: 'center'
p <- ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp))
p
```



## 2. Objetos Geométricos {.medium}

Una vez que las relaciones de sus variables hayan sido definidas por los mapeos estéticos, pueden usar y combinar diferentes objetos geométricos para generar diferentes visualizaciones.

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 8
#| fig-height: 4
#| dpi: 320
p + 
  geom_point(alpha = 0.3)  +
  geom_smooth(method = "loess")
```


## 2. Objetos Geométricos {.medium}

Los mapeos estéticos pueden aplicarse de manera diferente en cada geometría.

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 8
#| fig-height: 4
#| dpi: 320
p + 
  geom_point(aes(size = pop, col = continent), alpha = 0.3)  +
  geom_smooth(method = "loess")
```


## 2. Objetos Geométricos {.medium}

### Global vs Local

Cualquier mapeo estético en `ggplot()` se mostrará en TODAS las capas

```{r}
#| eval: true
#| echo: true
#| fig.align: 'center'
#| fig-width: 10
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp, color = continent)) +
  geom_point(alpha = 0.3)  +
  geom_smooth(method = "loess")
```


## 2. Objetos Geométricos {.medium}

### Global vs Local

Cualquier mapeo estético en los objetos geométricos `geom_layer` aplica SOLO en esas capas

```{r}
#| eval: true
#| echo: true
#| fig.align: 'center'
#| fig-width: 10

ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
  geom_point(aes(color = continent), alpha = 0.3)  +
  geom_smooth(method = "loess")
```


## 2. Objetos Geométricos {.medium}

De igual manera, tengan en cuenta que algunos objetos geométricos solo aceptan un subconjunto de asignaciones. Por ejemplo, `geom_density()` no sabe qué hacer con la asignación estética "y".

```{r}
#| echo: true
#| error: true
#| fig.align: 'center'
p + geom_density()
```

## 2. Objetos Geométricos {.medium}

Podemos solucionar este error siendo más cuidadosos con cómo construimos la gráfica.

```{r}
#| echo: true
#| fig.align: 'center'
#| fig-width: 8
#| fig-height: 4
#| dpi: 320
ggplot(data = gapminder) + ## i.e. No "global" aesthetic mappings"
  geom_density(aes(x = gdpPercap, fill = continent), alpha=0.3)
```

## 2. Objetos Geométricos - Tipos {.medium}

En la [documentación de ggplot](https://ggplot2.tidyverse.org/reference/index.html#section-layer-geoms){target="_blank"} encuentran todos los posibles objetos geométricos.

<center>

```{=html}
<iframe width=800 height=500 src="https://ggplot2.tidyverse.org/reference/index.html#section-layer-geoms" title="ggplot geoms"></iframe>
```

<center>

## 3. Construir la gráfica por capas {.medium}

Ya hemos visto cómo podemos encadenar (o "superponer") elementos consecutivos del gráfico  utilizando el conector `+`.

  - El que podamos crear y luego reutilizar un objeto intermedio del gráfico (por ejemplo, "p") es una prueba de esto
  
. . .

[Mediante este sencillo proceso de capas, pueden lograr visualizaciones con una complejidad realmente impresionantes.]{.hl .hl-dred}

  - No tienen que transformar sus datos originales; ggplot2 se encarga de todo eso
  
  - Las siguientes diapositivas les darán un ejemplo de esto...
  
## 3. Construir la gráfica por capas {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) 
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3)

```
:::
:::
  
## 3. Construir la gráfica por capas {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1")  ## Different colour scale
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1")  ## Different colour scale
```
:::
:::  
  
## 3. Construir la gráfica por capas {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma)  ## Different point (i.e. legend) scale
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma)  ## Different point (i.e. legend) scale
```
:::
:::
 
## 3. Construir la gráfica por capas  {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar)  ## Switch to logarithmic scale on x-axis. Use dollar units.
```
:::

::: {.column  width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar)  ## Switch to logarithmic scale on x-axis. Use dollar units.
```
:::
::: 

## 3. Construir la gráfica por capas {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar) + ## Switch to logarithmic scale on x-axis. Use dollar units.
  labs(x = "Log (GDP per capita)", y = "Life Expectancy")  ## Better axis titles
```
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar) + ## Switch to logarithmic scale on x-axis. Use dollar units.
  labs(x = "Log (GDP per capita)", y = "Life Expectancy") ## Better axis titles
```
:::
:::


## 3. Construir la gráfica por capas {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar) + ## Switch to logarithmic scale on x-axis. Use dollar units.
  labs(x = "Log (GDP per capita)", y = "Life Expectancy") + ## Better axis titles
  theme_minimal() ## Try a minimal (b&w) plot theme
```
:::

::: {.column  width="50%"}

```{r}
#| echo: false
#| fig.align: 'center'
p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar) + ## Switch to logarithmic scale on x-axis. Use dollar units.
  labs(x = "Log (GDP per capita)", y = "Life Expectancy") + ## Better axis titles
  theme_minimal() ## Try a minimal (b&w) plot theme
```
:::
:::

  
## 3. Construir la gráfica por capas {.medium}

```{r}
#| echo: false
#| fig.align: 'center'
p2 <-
  p +
  geom_point(aes(size = pop, col = continent), alpha = 0.3) +
  scale_color_brewer(name = "Continent", palette = "Set1") + ## Different colour scale
  scale_size(name = "Population", labels = scales::comma) + ## Different point (i.e. legend) scale
  scale_x_log10(labels = scales::dollar) + ## Switch to logarithmic scale on x-axis. Use dollar units.
  labs(x = "Log (GDP per capita)", y = "Life Expectancy") + ## Better axis titles
  theme_minimal() ## Try a minimal (b&w) plot theme
p2 
```


# dplyr {#dplyr}

<center>
![](img/dplyr.png){width=250}
</center>

## dplyr {.medium}

Es el principal paquete para transformar datos en `tidyverse`


::: columns
::: {.column width="50%"}
[dplyr.tidyverse.org](https://dplyr.tidyverse.org){target="_blank"}

```{=html}
<iframe width=600 height=375 src="https://dplyr.tidyverse.org/" title="dplyr home page"></iframe>
```
:::

::: {.column width="50%"}
[Cheat sheet](https://rstudio.github.io/cheatsheets/html/data-transformation.html){target="_blank"}

[![](img/dplyr-cheat-sheet.png)](https://rstudio.github.io/cheatsheets/html/data-transformation.html){target="_blank"}
:::
:::

## Símbolos Lógicos

::: {.tbl-classic .tbl-larger}

| Test                   | Meaning                    | Test                   | Meaning                  |
|:----------------------:|:---------------------------|:----------------------:|:--------------------------|
| `x < y`                | Menor que                  | `x %in% y`             | En (miembro de un grupo)     |
| `x > y`                | Mayor que               | `is.na(x)`             | Es missing                |
| `==`                   | Igual a                   | `!is.na(x)`            | No es missing            |
| `x <= y`               | Menor o igual a      |                        |                           |
| `x >= y`               | Mayor o igual a   |                        |                           |
| `x != y`               | Diferente a               |                        |                           |

:::


## Los verbos del dplyr 

::: {.cell}

|                                                         |                                              |
|---------------------------------------------------------|----------------------------------------------|
| Extraer filas con `filter()`                            | ![filter](img/filter.png){height=80px} |
| Extraer columnas con `select()`                         | ![select](img/select.png){height=80px} |
| Ordenar filas con `arrange()`                      | ![arrange](img/arrange.png){height=80px} |
| Crea nuevas columnas con `mutate()`                        | ![mutate](img/mutate.png){height=80px} |
| Resumir variables por grupo con `group_by() |> summarize()`   | ![summarize](img/summarize.png){height=80px} |

:::


## La sintaxis común {.medium}

<br>

::::: {.columns}

:::: {.column width="50%"}
```{r}
#| echo: false
#| results: asis

cat('<code><span style="background-color: #EFB3FF; font-weight: bold;">VERB</span>(<span style="background-color: #FFDFD1; font-weight: bold;">DATA</span>, 
<span style="background-color: #FFD0CF; font-weight: bold;">...</span>)</code>')

```

::::


:::: {.column width="50%"}
- <b><span style="background: #EFB3FF">VERB</span></b> = función/verbo de dplyr 
- <b><span style="background: #FFDFD1">DATA</span></b> = los datos a transformar
- <b><span style="background: #FFD0CF">...</span></b> = la operación que haga el verbo
::::
::::


## 1) dplyr::filter {.medium}

<br>

::::: {.columns}

:::: {.column width="50%"}
```{r}
#| echo: false
#| results: asis

cat('<code>filter(.data = <span style="background-color: #FFDFD1; font-weight: bold;">DATA</span>, 
<span style="background-color: #FFD0CF; font-weight: bold;">...</span>)</code>')
```

::::


:::: {.column width="50%"}
- <span style="background-color: #FFDFD1; font-weight: bold;">DATA</span> = los datos a transformar
- <span style="background-color: #FFD0CF; font-weight: bold;">...</span> = Una o más condiciones. <br>`filter()` selecciona cada fila para cual la condición es verdadera

::::
::::

## 1) dplyr::filter {.medium}

Podemos encadenar múltiples comandos de filtro con el pipe (`|>`), o simplemente separarlos dentro de un solo comando de filtro usando comas.

```{r}
#| echo: true
starwars |> 
  filter( 
    species == "Human", 
    height >= 190
    )
```


## Otros operadores lógicos {.medium}

::::: {.columns}

:::: {.column width="50%"}
`a & b` significa `a` y `b`

```{r}
#| echo: true
#| eval: false
starwars |> 
  filter( species == "Human" &
            height >= 190)
```

```{r}
#| echo: false
starwars |> 
  select(name, species, height) |>
  filter( species == "Human" & height >= 190) 
```
::::

:::: {.column .fragment width="50%"}
`a | b` significa `a` o `b`

```{r}
#| echo: true
#| eval: false
starwars |> 
  filter( species == "Human" | 
            height >= 190)
```

```{r}
#| echo: false
starwars |> 
  select(name, species, height) |>
  filter( species == "Human" | height >= 190) 
```
::::

:::::


## 1) dplyr::filter  {.medium}

Las [expresiones regulares](https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular){target="_blank"} también funcionan dentro de la función.

```{r}
#| echo: true
starwars |> 
  filter(grepl("Skywalker", name))
```

## 1) dplyr::filter  {.medium}

Un uso muy común de `filter` es identificar (o eliminar) casos con valores faltantes (missings). 

```{r}
#| echo: true
starwars |>
  filter(is.na(height))
```

. . .

Para eliminar valores faltantes, simplemente usen la negación: `filter(!is.na(height))`. Inténtenlo ustedes.



## Errores comunes {.medium}

Dos de los errores más comunes son:

  1. Usar "=" en vez de "=="
  2. No usar las comillas cuando las variables son de tipo texto

::::: {.columns}

:::: {.column width="50%"}

### Incorrecto 

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br>species  <span style="color: #3f56b0;">=</span> "Human")</code>')
```

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br>species == <span style="color: #3f56b0;">Human</span>)</code>')
```

::::


:::: {.column width="50%"}

### Correcto

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br>species <span style="color: #4db070;">==</span> "Human")</code>')
```


```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br>species == <span style="color: #4db070;">"Human"</span>)</code>')
```
::::
::::


## Errores comunes {.medium}

Otros errores comunes son:

  3. Tratar de agregar las condiciones sin comas o conectores lógicos
  4. Usar las comas cuando se pueden usar los conectores lógicos

::::: {.columns}

:::: {.column width="50%"}

### Incorrecto

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br> <span style="color: #3f56b0;">170 < height < 190</span> )</code>')
```

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br> <span style="color: #3f56b0;">name = "Anakin Skywalker", name = "Rey", name = "Finn" </span>)</code>')
```

::::


:::: {.column width="50%"}

### Correcto

```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br> <span style="color: #4db070;">height > 170, height < 190</span>)</code>')
```


```{r}
#| echo: false
#| results: asis
cat('<code>filter(starwars,<br> <span style="color: #4db070;">name %in% c("Anakin Skywalker", "Rey", "Finn") </span>)</code>')
```
::::
::::

## 2) dplyr::arrange {.medium}

```{r}
#| echo: true
starwars |> 
  arrange(birth_year) 
```
. . .

<br/>*Nota:* Si se organiza una variable basado en caracteres, se ordenarán alfabéticamente. Intenten ordenando los datos según la variable "name".

## 2) dplyr::arrange {.medium}

También podemos organizar los elementos en orden descendente utilizando `arrange(desc())`.

```{r}
#| echo: true
starwars |>
  arrange(desc(birth_year))
```



## 3) dplyr::select {.medium}

Utilicen comas para seleccionar varias columnas de una base de datos (usen "first:last" para columnas consecutivas). Anulen la selección de una columna con "-".

```{r}
#| echo: true
starwars |> 
  select(name:skin_color, species, -height)
```

## 3) dplyr::select {.medium}

También pueden cambiar el nombre de algunas (o todas) de las variables seleccionadas.

```{r}
#| echo: true
starwars |>
  select(alias=name, crib=homeworld, sex=gender)
```

. . .

Si solo desean cambiar el nombre de las columnas sin seleccionarlas, pueden utilizar `rename`. Prueben esto ahora reemplazando `select(...)` en el fragmento de código anterior por `rename(...)`.


## 3) dplyr::select  {.medium}

La opción `select(contains(PATTERN))` proporciona un buen atajo en casos relevantes.

```{r}
#| echo: true
starwars |> 
  select(name, contains("color"))
```

## 3) dplyr::select  {.medium}

La opción `select(..., everything())` es otro atajo útil si solo desean traer algunas variables al "frente" de la base de datos.

```{r}
#| echo: true
starwars |> 
  select(species, homeworld, everything()) |>
  head(5)
```



## 4) dplyr::mutate {.medium}

Pueden crear nuevas columnas desde cero o (más comúnmente) como transformaciones de columnas existentes.

```{r}
#| echo: true
starwars |> 
  select(name, birth_year) |>
  mutate(dog_years = birth_year * 7) |>
  mutate(comment = paste0(name, " is ", dog_years, " in dog years."))
```


## 4) dplyr::mutate {.medium}

*Nota:* `mutate` tiene en cuenta el orden, por lo que pueden encadenar múltiples cambios en un sólo uso de la función.

```{r}
#| echo: true
starwars |> 
  select(name, birth_year) |>
  mutate(
    dog_years = birth_year * 7, ## Separate with a comma
    comment = paste0(name, " is ", dog_years, " in dog years.")
    )
```


## ifelse {.medium}

::::: {.columns}

:::: {.column width="50%"}
```{r}
#| echo: false
#| results: asis

cat('<code>ifelse(<span style="background-color: #FFC0DC; font-weight: bold;">TEST</span>, 
<span style="background-color: #FFDFD1; font-weight: bold;">VALUE_IF_TRUE</span>, 
<span style="background-color: #CBB5FF; font-weight: bold;">VALUE_IF_FALSE</span>)</code>')

```

::::


:::: {.column width="50%"}
- <b><span style="background: #FFC0DC">TEST</span></b> = Una condición lógica
- <b><span style="background: #FFDFD1">VALUE_IF_TRUE</span></b> = Lo que pasa si la condición se cumple
- <b><span style="background: #CBB5FF">VALUE_IF_FALSE</span></b> = Lo que pasa si la condición **no** se cumple
::::
::::


## 4) dplyr::mutate  {.medium}

Los operadores lógicos y condicionales también funcionan bien con `mutate`.

```{r}
#| echo: true
starwars |> 
  select(name, height) |>
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) |> 
  mutate(tall1 = height > 180) |>
  mutate(tall2 = ifelse(height > 180, "Tall", "Short")) ## Same effect, but can choose labels
```


## 4) dplyr::mutate {.medium}

Por último, la combinación de `mutate` con la  función `across` les permite trabajar fácilmente en un subconjunto de variables. Por ejemplo:

```{r}
#| echo: true
#| code-line-numbers: "3|1,2,3,4"
starwars |> 
  select(name:eye_color) |> 
  mutate(across(where(is.character), toupper)) |>
  head(5)
```

## 5) dplyr::summarise {.medium}

Particularmente útil en combinación con el comando `group_by`.

```{r}
#| echo: true
starwars |> 
  group_by(species, gender) |> 
  summarise(mean_height = mean(height, na.rm = TRUE))
```


## 5) dplyr::summarise  {.medium}

Tengan en cuenta que incluir `na.rm = TRUE` (o su alias `na.rm = T`) suele ser una buena idea con estas funciones. De lo contrario, cualquier valor faltante se propagará también al valor resumido.


```{r}
#| echo: true
## Probably not what we want
starwars |> 
  summarise(mean_height = mean(height))
## Much better
starwars |> 
  summarise(mean_height = mean(height, na.rm = TRUE))
```


## 5) dplyr::summarise {.medium}

El mismo flujo de código basado en `across` que vimos con `mutate` unas diapositivas atrás también funciona con `summarise`. Por ejemplo:

```{r}
#| echo: true
#| code-line-numbers: "3|1,2,3,4"
starwars |> 
  group_by(species) |> 
  summarise(across(where(is.numeric), mean, na.rm=T)) |>
  head(5)
```


## Otros verbos del dplyr {.medium}


`slice`: Selecciona filas por posición en lugar de filtrar por valores.

```{r}
starwars |>
  slice(c(1, 5))
```

. . .


`pull`: Extrae una columna de un data frame como un vector o un escalar.

```{r}
starwars |> 
  filter(sex == "female") |>
  pull(height)
```



## Otros verbos del dplyr {.medium}

`count` y `distinct`: Cuentan y aíslan observaciones únicas.

::: columns
::: {.column width="50%"}

```{r}
starwars |>
  count(species)
```
:::

::: {.column width="50%"}

```{r}
starwars |>
  distinct(species)
```
:::
:::

## Otros verbos del dplyr {.medium}

- También se puede usar una combinación de `mutate`, `group_by` y `n()`

```{r}
starwars |>
  select(name, species) |>
  group_by(species) |>
  mutate(num = n()) |>
  head(10)
```


# Modificando un data frame {#dataframe}

## Cómo y cuándo modificar un data frame {.medium}

Creemos un data frame para usar como ejemlo:

```{r}
#| message: false

library(tidyverse)
df <- tibble(x = c(1, 2, 3, 4, 5), y = c("a", "a", "b", "c", "c"))
df
```

## Cómo y cuándo modificar un data frame {.medium}

::: columns
::: {.column .fragment width="50%"}
> **Haga algo y muéstrelo**

```{r}
df |>
  mutate(x = x * 2)
df
```
:::

::: {.column .fragment width="50%"}
> **Haga algo y guarde el resultado**

```{r}
df <- df |>
  mutate(x = x * 2)
df
```
:::
:::

## Cómo y cuándo modificar un data frame {.medium}

::: columns
::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, modifique el original**

```{r}
#| code-line-numbers: "5-7"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df <- df |>
  mutate(x = x * 2)
df
```
:::

::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, *no* modifique el original**

```{r}
#| code-line-numbers: "5-7"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df_new <- df |>
  mutate(x = x * 2)
df_new
```
:::
:::

## Cómo y cuándo modificar un data frame {.medium}

::: columns
::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, modifique el original *cuando no debería***

```{r}
#| code-line-numbers: "5-8"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df <- df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
df
```
:::

::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, *no* modifique el original *cuando no debería***

```{r}
#| code-line-numbers: "5-8"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df_summary <- df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
df_summary
```
:::
:::

## Cómo y cuándo modificar un data frame {.medium}

::: columns
::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, modifique el**\
> ***data frame original***

```{r}
#| code-line-numbers: "5-7"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df <- df |>
  mutate(z = x + 2)
df
```
:::

::: {.column .fragment width="50%"}
> **Haga algo, guarde el resultado, modifique la**\
> ***columna original***

```{r}
#| code-line-numbers: "5-7"

df <- tibble(
  x = c(1, 2, 3, 4, 5), 
  y = c("a", "a", "b", "c", "c")
)
df <- df |>
  mutate(x = x + 2)
df
```
:::
:::



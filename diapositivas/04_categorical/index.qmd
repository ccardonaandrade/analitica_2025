---
title: Anal칤tica de los Negocios
author: Carlos Cardona Andrade
subtitle: Explorando datos categ칩ricos
execute:
  freeze: auto
  echo: true
  fig-width: 6
  fig-height: 5
format:
  revealjs: 
   theme: ../slides.scss
   header-includes: |
      <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"/>
   slide-number: true
   show-slide-number: all
   transition: fade
   progress: true
   multiplex: false
   scrollable: false
   preview-links: false
   hide-inactive-cursor: true
   highlight-style: printing
   pause: true
---
     
```{r}
#| eval: true
#| echo: false
library(knitr)
library(forcats)
library(patchwork)
library(lubridate)
library(cowplot)
library(tidyverse)
library(kableExtra)
library(openintro)
library(janitor)
library(ggrepel)
library(waffle)
library(ggmosaic)
```


## Plan para hoy

1. [Datos categ칩ricos](#intro)

2. [Visualizandos una variable categ칩rica](#1category)

3. [Visualizandos dos variables categ칩ricas](#2categories)

4. [Comparando variables num칠ricas entre grupos](#acrossgroups)

5. [Probabilidad](#probabilidad)

6. [La Distribuci칩n Normal](#distnormal)


# Datos categ칩ricos {#intro}

## Tipos de variables

```{r}
#| echo: false
#| fig-align: center

par_og <- par(no.readonly = TRUE) # save original par
par(mar = rep(0, 4))
plot(c(-0.15, 1.3), 0:1, type = "n", axes = FALSE)

text(0.6, 0.9, "Variables")
rect(0.4, 0.8, 0.8, 1)

text(0.25, 0.5, "Num칠ricas")
rect(0.1, 0.4, 0.4, 0.6)
arrows(0.45, 0.78, 0.34, 0.62, length = 0.08)

text(0.9, 0.5, "Categ칩ricas")
rect(0.73, 0.4, 1.07, 0.6)
arrows(0.76, 0.78, 0.85, 0.62, length = 0.08)

text(0, 0.1, "Discretas")
rect(-0.17, 0, 0.17, 0.2)
arrows(0.13, 0.38, 0.05, 0.22, length = 0.08)

text(0.39, 0.1, "Continuas")
rect(0.25, 0, 0.53, 0.2)
arrows(0.35, 0.38, 0.4, 0.22, length = 0.08)

text(0.77, 0.105, "Ordinales")
rect(0.64, 0, 0.9, 0.2)
arrows(0.82, 0.38, 0.77, 0.22, length = 0.08)

text(1.12, 0.1, "Nominales")
rect(0.99, 0, 1.25, 0.2)
arrows(1.02, 0.38, 1.1, 0.22, length = 0.08)
par(par_og) # restore original par
```
   

## Variables Categ칩ricas

```{r}
#| echo: false
#| fig-align: center

par_og <- par(no.readonly = TRUE) # save original par
par(mar = rep(0, 4))
plot(c(-0.15, 1.3), 0:1, type = "n", axes = FALSE)

text(0.6, 0.9, "Variables")
rect(0.4, 0.8, 0.8, 1)

text(0.25, 0.5, "Num칠ricas", col = "gray50")
rect(0.1, 0.4, 0.4, 0.6, border = "gray50")
arrows(0.45, 0.78, 0.34, 0.62, length = 0.08, col = "gray50")

text(0.9, 0.5, "Categ칩ricas")
rect(0.73, 0.4, 1.07, 0.6)
arrows(0.76, 0.78, 0.85, 0.62, length = 0.08)

text(0, 0.1, "Discretas", col = "gray50")
rect(-0.17, 0, 0.17, 0.2, border = "gray50")
arrows(0.13, 0.38, 0.05, 0.22, length = 0.08, col = "gray50")

text(0.39, 0.1, "Continuas", col = "gray50")
rect(0.25, 0, 0.53, 0.2, border = "gray50")
arrows(0.35, 0.38, 0.4, 0.22, length = 0.08, col = "gray50")

text(0.77, 0.105, "Ordinales")
rect(0.64, 0, 0.9, 0.2)
arrows(0.82, 0.38, 0.77, 0.22, length = 0.08)

text(1.12, 0.1, "Nominales")
rect(0.99, 0, 1.25, 0.2)
arrows(1.02, 0.38, 1.1, 0.22, length = 0.08)
par(par_og) # restore original par
```

```{r}
#| echo: false
loans <- loans_full_schema |>
  mutate(application_type = as.character(application_type)) |>
  filter(application_type != "") |>
  mutate(
    homeownership = tolower(homeownership),
    homeownership = fct_relevel(homeownership, "rent", "mortgage", "own"),
    application_type = fct_relevel(application_type, "joint", "individual")
  )

loans_individual_rent <- loans |>
  filter(
    application_type == "individual",
    homeownership == "rent"
  ) |>
  nrow()
```


# Visualizandos una variable categ칩rica {#1category}



## Tabla de Frecuencia {.medium}

- Una variable categ칩rica se resume mediante una tabla que muestra la [frecuencia]{.hl .hl-blue} o el [porcentaje]{.hl .hl-blue} de casos en cada categor칤a

- Suele representarse mediante un gr치fico de barras o un gr치fico de torta

<br>

::: {.tbl-classic .tbl-larger}

```{r}
#| echo: false
#| fig-align: center
loans |>
  count(homeownership, name = "Frequency") |>
  adorn_totals(where = "row") |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(
    bootstrap_options = c("striped", "condensed"),
    latex_options = c("striped"), full_width = FALSE
  ) |>
  column_spec(1:2, width = "10em")
```

:::

## Gr치fico de barras {.medium}

::: columns
::: {.column width="50%"}

Un gr치fico de barras es la forma m치s com칰n de representar una 칰nica variable categ칩rica. 

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```
:::
:::

## Gr치fico de barras {.medium}

::: columns
::: {.column width="50%"}

Un gr치fico de barras en el que se muestran proporciones en lugar de frecuencias se llama gr치fico de barras de frecuencia relativa.
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras en R

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1|2|3,4|5"

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership",
       y = "Frequency") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras en R {.medium}


::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1,2,3|4,5|6|7,8|9"

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership,
             y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership",
       y = "Proportion") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```
:::
:::

## Gr치fico de barras

```{r}
#| echo: false
#| fig-subcap:
#|   - Counts of homeownership.
#|   - Proportions of homeownership.
#| fig-width: 5
#| layout-ncol: 2
ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```


## 游눩 Ejercicio 1  {.medium}

1. Usando la plantilla con la que ya hemos trabajado anteriormente, establezcan el directorio de trabajo y carguen los paquetes `tidyverse` y `janitor` (Este 칰ltimo inst치lenlo por lo que es la primera vez que lo usamos).

2. Importen los datos `credit_demographics` con el nombre `credit` usando la funci칩n `read.csv()`.

3. Exploren los datos usando la funci칩n `glimpse()`.

4. En ocasiones, algunos nombres de variables pueden ser inconsistentes o dif칤ciles de manejar. El paquete `janitor` facilita este proceso. Ejecuten la siguiente l칤nea de c칩digo y luego vuelvan a utilizar la funci칩n `glimpse()`. 쯅otan la diferencia en los nombres?

```{r}
#| eval: false
credit <- credit |>
  clean_names()
```


## 游눩 Ejercicio 1  {.medium}

5. Como pueden notar en el punto anterior, la variable `default` contiene 0s y 1s. Vamos a convertirla en una variable de texto (`string`) para que sea m치s f치cil de interpretar en los gr치ficos. Ejecuten el siguiente c칩digo para crear una nueva variable:

```{r}
#| eval: false
credit <- credit |>
  mutate(
    default_string = case_when(
      default == 1 ~ "Default",
      default == 0 ~ "No Default",
      TRUE ~ NA_character_  # Assign NA for any unmatched values
    ))
```

6. Usando esta nueva variable `default_string` y el paquete `ggplot`, construyan un gr치fico de barras para visualizar cu치ntos clientes est치n en *default* y cu치ntos no. Aseg칰rense de incluir etiquetas y un t칤tulo para hacer el gr치fico m치s informativo.




## Gr치ficos de torta {.medium}

::: columns
::: {.column width="50%"}

- Las 치reas de las porciones representan los porcentajes de las categor칤as

- Generalmente es m치s dif칤cil comparar los tama침os de los grupos en un gr치fico de pastel que en un gr치fico de barras
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  count(homeownership) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = homeownership, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(aes(x = 1, label = homeownership, y = text_y)) +
  coord_polar("y", start = 0) +
  scale_fill_openintro("hot") +
  theme_void() +
  labs(title = "Homeownership")
```
:::
:::

## Gr치ficos de torta {.medium}



```{r}
#| echo: false
#| fig-subcap: 
#|   - Pie chart
#|   - Bar plot
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  count(homeownership) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = homeownership, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(aes(x = 1, label = homeownership, y = text_y)) +
  coord_polar("y", start = 0) +
  scale_fill_openintro("hot") +
  theme_void() +
  labs(title = "Homeownership")

loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  ggplot(aes(x = homeownership, fill = homeownership)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_openintro("hot") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```


## Gr치ficos de torta {.medium}


::: columns
::: {.column width="50%"}

- Es mucho m치s f치cil hacer un gr치fico de pastel incorrecto que un gr치fico de barras incorrecto.

- En un gr치fico de pastel, las categor칤as deben representar un todo. No existe esta restricci칩n para un gr치fico de barras.

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  count(grade) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = grade, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(
    aes(x = 1.4, label = grade, y = text_y), nudge_x = 0.3, segment.size = 0.5
  ) +
  coord_polar(theta = "y") +
  scale_fill_openintro("cool") +
  theme_void() +
  labs(title = "Loan grade")
```
:::
:::


## Gr치ficos de torta {.medium}



```{r}
#| echo: false
#| fig-subcap: 
#|   - Pie chart
#|   - Bar plot
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
loans |>
  count(grade) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = grade, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(
    aes(x = 1.4, label = grade, y = text_y), nudge_x = 0.3, segment.size = 0.5
  ) +
  coord_polar(theta = "y") +
  scale_fill_openintro("cool") +
  theme_void() +
  labs(title = "Loan grade")

loans |>
  ggplot(aes(x = grade, fill = grade)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_openintro("cool") +
  labs(x = "Loan grade", y = "Frequency") + 
  theme_minimal()
```


## Gr치fico de torta en R {.medium}

::: columns
::: {.column width="50%"}

- Existen diferentes maneras de hacer un gr치fico de torta, m치s all치 de `ggplot`

- En [Pie Charts](https://r-graph-gallery.com/pie-plot.html){target="_blank"} encuentran una gu칤a explicando diferentes maneras de hacerlo en <i class="fa-brands fa-r-project"></i>

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/pie-plot.html"></iframe>
```
:::
:::



## Gr치fico de Waffle {.medium}

```{r}
#| echo: false
#| fig-subcap:
#|   - "Homeownership: rent, mortgage, and own"
#|   - "Loan status: fully paid, in grace period, and late"
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%

loans |>
  count(homeownership) |>
  ggplot(aes(fill = homeownership, values = n)) +
  geom_waffle(
    color = "white", flip = TRUE, make_proportional = TRUE, na.rm = TRUE
  ) +
  labs(fill = NULL, title = "Homeownership") +
  scale_fill_openintro("hot") +
  coord_equal() +
  theme_enhance_waffle() +
  theme_void() +  # Removes background, grid lines, and axis text
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 13)
  )

loans |>
  count(loan_status) |>
  ggplot(aes(fill = loan_status, values = n)) +
  geom_waffle(
    color = "white", flip = TRUE, make_proportional = TRUE, na.rm = TRUE
  ) +
  labs(fill = NULL, title = "Loan status") +
  scale_fill_openintro("four") +
  coord_equal() +
  theme_enhance_waffle() +
  theme_void() +  # Removes background, grid lines, and axis text
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 13)
  ) +
  guides(fill = guide_legend(nrow = 2))
```


## Gr치fico de Waffle {.medium}

- Los gr치ficos de waffle son otra t칠cnica 칰til para visualizar datos categ칩ricos, mostrando la proporci칩n de cada categor칤a

- Al igual que los gr치ficos de pastel, funcionan mejor cuando el n칰mero de categor칤as es bajo

- A diferencia de los gr치ficos de pastel, facilitan la comparaci칩n de proporciones que no representan fracciones simples



## Gr치fico de Waffle en R {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de gr치fico va m치s all치 de la funcionalidad de `ggplot`

- Por lo tanto no lo explicar칠 en clase, pero ac치 les dejo recursos para que aprendan por su cuenta: 

  1. La p치gina del paquete [waffle](https://github.com/hrbrmstr/waffle){target="_blank"}

  2. [Waffle Charts](https://r-graph-gallery.com/waffle.html){target="_blank"} provee una gu칤a de c칩mo crear este tipo de gr치fico

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/waffle.html" title="waffle plots"></iframe>
```
:::
:::


# Visualizandos dos variables categ칩ricas {#2categories}


## Tablas de Contingencia {.medium}

- Una tabla que resume datos para dos variables categ칩ricas de esta manera se llama [tabla de contingencia]{.hl .hl-blue}

- Cada valor en la tabla representa la cantidad de veces que ocurri칩 una combinaci칩n particular de resultados de las variables

<br>

::: {.tbl-classic .tbl-larger}

```{r}
#| echo: false
#| fig-align: center

loans |>
  count(application_type, homeownership) |>
  pivot_wider(names_from = homeownership, values_from = n) |>
  select(application_type, rent, mortgage, own) |>
  adorn_totals(where = c("row", "col")) |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(
    bootstrap_options = c("striped", "condensed"),
    latex_options = c("striped")
  ) |>
  add_header_above(c(" " = 1, "homeownership" = 3, " " = 1)) |>
  column_spec(1, width = "8em") |>
  column_spec(2:5, width = "5em")
```

:::

## Gr치fico de barras apiladas {.medium}

::: columns
::: {.column width="50%"}

- Los solicitantes de pr칠stamos viven m치s com칰nmente en viviendas con hipoteca

- Sin embargo, bas치ndose solo en este gr치fico, es dif칤cil determinar c칩mo var칤an los tipos de solicitud entre los niveles de tenencia de vivienda

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras estandarizado {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de visualizaci칩n es 칰til para comprender la proporci칩n del tipo de solicitudes en cada nivel de tenencia de vivienda

- Adem치s, dado que las proporciones del tipo de pr칠stamos var칤an entre los grupos, podemos concluir que estas dos variables est치n asociadas en esta muestra


:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras dobles {.medium}

::: columns
::: {.column width="50%"}

- Dentro de cada nivel de tenencia de vivienda, las solicitudes individuales son m치s comunes que las solicitudes conjuntas

- Las solicitudes conjuntas son m치s comunes entre los solicitantes con hipoteca, en comparaci칩n con los inquilinos y los propietarios.

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::



## Gr치fico de barras apiladas en R

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1,2|3|4,5|6,7,8"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras estandarizado en R {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "3|1,2,3,4,5,6,7,8,9"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gr치fico de barras dobles en R {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "3|1,2,3,4,5,6,7,8,9"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Explorando dos variables categ칩ricas

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 2.5
#| fig-height: 2.5
#| layout: [[50, 50], [-22, 56, -22]]
ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill", show.legend = FALSE) +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal() +
  theme(legend.position = "bottom")
```


## 游눩 Ejercicio 2  {.medium}

1. Con base en el c칩digo con el que crearon la variable `default_string`, generen la variable `marriage_string` seg칰n los valores de la variable `marriage`:

   - 1 $\rightarrow$ *married*
  
   - 2 $\rightarrow$ *single* 
   
   - 3 $\rightarrow$ *other*

2. Creen un gr치fico de barras (apilados, dobles o estandarizado) para visualizar la relaci칩n entre el estado civil (`marriage_string`) y si el cliente est치 en default (`default_string`).

3. 쯈u칠 pueden concluir a partir del gr치fico anterior?



## Gr치fico de mosaico

```{r}
#| echo: false
#| fig-subcap: 
#|   - Homeownership.
#|   - Homeownership vs. application type.
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
ggplot(loans) +
  geom_mosaic(aes(x = product(homeownership)), fill = IMSCOL["green", "full"]) +
  labs(x = "Homeownership", y = "") +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) + 
  theme(
    panel.background = element_rect(fill = "white", color = NA),  # Remove grey background
    plot.background = element_rect(fill = "white", color = NA),   # Remove grey plot background
    panel.grid = element_blank(),  # Remove grid lines
    axis.title = element_text(size = 12),  # Keep axis labels
    axis.text = element_text(size = 10)    # Keep axis text
  )

ggplot(loans) +
  geom_mosaic(aes(x = product(homeownership), fill = application_type)) +
  scale_fill_manual(values = c(IMSCOL["blue", "full"], IMSCOL["yellow", "full"])) +
  labs(x = "Homeownership", y = "Application type") +
  guides(fill = FALSE) + 
  theme_mosaic()   # Removes background, grid lines, and axis text

```

## Gr치fico de mosaico {.medium}

- Un gr치fico mosaico es otra manera de visualizar tablas de contingencia que se asemeja a un gr치fico de barras apiladas estandarizado

- La ventaja consiste en a칰n poder ver el tama침o relativo de los grupos de la variable principal

. . . 

$$
\small
\begin{array}{rcl}
\text{Area del segmento} &=& (\text{ancho de la barra}) \times (\text{longitud del segmento}) \\  
&=& \text{frecuencia de la fila} \times (\text{proporcion de la fila}) \\  
&=& \text{frecuencia de la fila} \times \dfrac{\text{frecuencia de la celda}}{\text{frecuencia de la fila}} \\  
&=& \text{frecuencia de la celda}  
\end{array}
$$

## Gr치fico de mosaico {.medium}

Es importante pensar cu치l variable va en el eje horizontal y cu치l en el vertical. En ocasiones, una es m치s *explicativa* que la otra.

```{r}
#| echo: false
#| fig-width: 10
#| fig-align: center
#| out-width: 100%
ggplot(loans) +
  geom_mosaic(aes(x = product(application_type), fill = homeownership)) +
  scale_fill_openintro("hot") +
  labs(x = "Application type", y = "Homeownership") +
  guides(fill = FALSE) + 
  theme_mosaic()
```


## Gr치fico de Mosaico en R {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de gr치fico tambi칠n va m치s all치 de la funcionalidad de `ggplot`

- La p치gina del paquete [ggmosaic](https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html){target="_blank"} es un buen sitio para empezar a practicar por su cuenta


:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html" title="waffle plots"></iframe>
```
:::
:::

# Comparando variables num칠ricas entre grupos {#acrossgroups}

## Histograma y Diagrama de Caja entre grupos {.medium}


```{r}
#| echo: false
#| out-width: 100%
#| fig-asp: 0.23
#| fig-align: center
library(gapminder)
gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot() +
  geom_histogram(aes(x=lifeExp, fill=continent), alpha = 0.5, bins=10) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       fill = "Continent") +
  theme_minimal()

gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot() +
  geom_boxplot(aes(x=lifeExp, y=continent, color=continent)) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       color = "Continent") +
  theme_minimal()
```


## Ridge plot {.medium}

Otro tipo de visualizaci칩n 칰til para comparar datos num칠ricos entre grupos es el gr치fico de crestas (ridge plot), que combina gr치ficos de densidad de varios grupos en la misma escala dentro de una 칰nica ventana de visualizaci칩n


```{r}
#| echo: false
#| out-width: 100%
#| fig-asp: 0.23
#| fig-align: center
library(ggridges)
gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot(aes(x=lifeExp, y=continent, color=continent, fill=continent)) +
  geom_density_ridges(alpha = 0.5) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       color = "Continent",
       fill = "Continent") +
  theme_minimal()
```


## Ridge plot {.medium}

Establecer el color seg칰n la variable num칠rica en lugar de la categ칩rica puede ser bastante 칰til para contar la historia de los datos.


```{r}
#| echo: false
#| out-width: 100%
#| fig-align: center
library(viridis)
library(hrbrthemes)

gapminder |>
  filter(year %in% c(1952, 1962, 1972, 1982, 1992, 2002)) |>
ggplot(aes(x = lifeExp, y = factor(year), fill = stat(x))) +
  geom_density_ridges_gradient() +
  scale_fill_viridis_c(name = "Life Expectancy (years)", option = "C")+
  labs(y = "Year",
       x = "Life Expectancy (years)") + 
  theme_ipsum() +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      strip.text.x = element_text(size = 8)
    )

```


## Ridge plot en R {.medium}

::: columns
::: {.column width="50%"}

- Quiero destacar la flexibilidad de <i class="fa-brands fa-r-project"></i> para mejorar con la incorporaci칩n de paquetes

- La p치gina del paquete [ggridges](https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html){target="_blank"} es un buen sitio para profundizar en este tipo de gr치fico

- [Basic ridgeline plot](https://r-graph-gallery.com/294-basic-ridgeline-plot.html){target="_blank"} tambi칠n explica este gr치fico y tiene buenos ejemplos

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/294-basic-ridgeline-plot.html" title="ridge plots"></iframe>
```
:::
:::


## Maneras de visualizar relaciones entre variables {.medium}

- num칠rica v.s. num칠rica
  
    - Diagramas de dispersi칩n
    
    
- categ칩rica v.s. categ칩rica

    - Tablas de contigencia
    - Gr치ficos de barra (apilados, dobles, estandarizados)
    - Gr치fico de mosaico
    
- categ칩rica v.s. num칠rica
 
    - Diagramas de caja entre grupos
    - Ridge plots
    
# Probabilidad {#probabilidad}

## Probabilidad {.medium}

- Una probabilidad se define como la siguiente proporci칩n:

$$P=\dfrac{\#\, \text{resultados deseados}}{\#\, \text{resultados posibles}}$$

- Por ejemplo, al tirar un dado la probabilidad de obtener un 2 luego de lanzar un dado es:

$$P(2)=\dfrac{1}{6}=0.166=16.66\%$$

## Probabilidad {.medium}

1. Las probabilidades siempre est치n entre 0 y 1.
  - Una probabilidad igual a 0 indica que el evento nunca va a ocurrir. 
  - Por otro lado, si es igual a 1 indica que con toda seguridad el evento tendr치 lugar.
  
2. $\sum{P}=1$
3. La probabilidad de que un evento **no ocurra** es igual a 1 menos la probabilidad de que el evento ocurra.
  - Al tirar un dado:
  
$$P(\sim2)=1-P(2)=1-\dfrac{1}{6}=\dfrac{5}{6}$$

## Probabilidad {.medium}

4. Si A y B son eventos alternativos (no se superponen), entonces $P(A$ $o$ $B)=P(A)+P(B)$
  - Siguiendo con el ejemplo del dado:
  
$$P(2\, o\,  3)=P(2)+P(3)=\dfrac{1}{6}+\dfrac{1}{6}=\dfrac{2}{6}=\dfrac{1}{3}$$

## Probabilidad {.medium}

5. Si A y B son eventos que se superponen (ocurrencia conjunta), entonces $P(A$ $o$ $B)=P(A)+P(B)-P(A$ $y$ $B)$
  - 쮺u치l ser칤a la probabilidad de sacar un n칰mero par o un 6?
  
$$P(Par\, o\,  6)=P(Par)+P(6)=\dfrac{3}{6}+\dfrac{1}{6}=\dfrac{4}{6}=\dfrac{2}{3} \quad \text{Incorrecto} $$

$$P(Par\, o\,  6)=P(Par)+P(6)-P(Par\, y\,  6)=\dfrac{3}{6}+\dfrac{1}{6}-\dfrac{1}{6}=\dfrac{3}{6}=\dfrac{1}{2} \quad \text{Correcto} $$

## Probabilidad {.medium}

6. Si A y B son **independientes**, entonces $P(A\, y\, B)=P(A) \cdot P(B)$
  - 쮺u치l es la probabilidad de sacar 2 luego de tirar el dado dos veces?
  
$$P(2\, luego\, 2)=P(2) \cdot P(2)=\dfrac{1}{6} \cdot \dfrac{1}{6}=\dfrac{1}{36}$$

## Probabilidad {.medium}

- Es importante tener en cuenta si existe reemplazo o no.
- Por ejemplo, si un recipiente tiene 4 pelotas amarillas y 2 azules. 쮺u치l es la probabilidad de sacar una amarilla y luego una azul sin reemplazo?

$$P(Amarilla\, luego\, Azul)=P(Amarilla) \cdot P(Azul)=\dfrac{4}{6} \cdot \dfrac{2}{5}=\dfrac{8}{30}=\dfrac{4}{15}$$

# La Distribuci칩n Normal {#distnormal}


## Escala de frecuencia de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

Retomemos la distribuci칩n de la expectativa de vida en los datos `gapminder`.

Para los histogramas en una escala de frecuencia, la altura de las barras = cantidad de observaciones en ese intervalo.

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp), 
                 color = "black", fill = "darkblue", bins = 30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  labs(x="Life Expectancy (years)",
       y="Frequency") +
  theme_minimal()

```
::::

:::::




## Escala de densidad de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

Para un histograma en una escala de densidad,  
el 치rea de la barra = proporci칩n de observaciones en ese intervalo. 

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                 color = "black", fill = "darkblue", bins = 30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal()

```
::::

:::::




## Escala de densidad de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

En una escala de densidad, la [proporci칩n]{.hl .hl-blue} de pa칤ses con expectativas de vida entre 60 y 70 a침os = el [치rea]{.hl .hl-blue} bajo la curva del histograma entre 60 y 70

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6


gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density), 
                     fill = after_stat(x) >= 60 & after_stat(x) <= 70), 
                 color = "black", bins=30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "darkblue")) + 
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() +
  theme(legend.position = "none")  # Hides the legend

```
::::

:::::




## Del Histograma a la Curva de Densidad {.medium}


::::: {.columns}

:::: {.column width="50%"}

Podr칤amos intentar aproximar un histograma mediante una curva suave, 
llamada una [funci칩n de densidad (probabilidad)]{.hl .hl-blue}.

1. Una funci칩n de densidad nunca es negativa

2. El 치rea total bajo la curva es siempre 1 o 100%

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                     fill = "lightblue", 
                 color = "#c8d9ed", bins=30) +
  geom_density(aes(x=lifeExp), color="darkblue")+
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() 
```
::::

:::::





## Del Histograma a la Curva de Densidad {.medium}


::::: {.columns}

:::: {.column width="50%"}

Por lo tanto, la proporci칩n de pa칤ses con expectativas de vida entre 60 y 70 a침os se puede estimar como el [치rea sombreada bajo la curva]{.hl .hl-blue}. La proporci칩n exacta es el 치rea bajo el histograma.

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

density_data <- density(gapminder$lifeExp)
density_df <- data.frame(x = density_data$x, y = density_data$y)

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                 fill = "lightblue", 
                 color = "#c8d9ed", bins=30) +
  geom_density(aes(x = lifeExp), color = "darkblue") +
  geom_area(data = subset(density_df, x >= 60 & x <= 70),
            aes(x = x, y = y),
            fill = "darkblue",
            alpha = 0.3) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() 
```
::::

:::::


## Variables continuas y Curvas de densidad {.medium}

La distribuci칩n de probabilidad de una variable aleatoria continua se describe mediante una curva de densidad.  

Si $Y$ es una variable aleatoria continua, $P(a < Y < b)$ es el 치rea bajo la curva de densidad de $Y$ sobre el intervalo entre $a$ y $b$.  

![](img/continuous.png){height="150" fig-align="center"}

. . . 

Nota: todas las distribuciones de probabilidad continuas asignan una probabilidad de cero a cada resultado individual: $P(Y=y)=0$


## Distribuci칩n Normal {.medium}

La distribuci칩n normal (campana de Gauss) es una familia de curvas de densidad que son [sim칠tricas]{.marker-hl} y con [forma de campana]{.marker-hl}. Se definen por su media ${\color{orange} \mu}$ y su desviaci칩n est치ndar ${\color{orange} \sigma}$, con notaci칩n $N(\mu,\sigma)$.


```{r}
#| echo: false
#| fig-subcap:
#|   - Mean = 0, SD = 1
#|   - Mean = 19, SD = 4
#| fig-asp: 0.5
#| out-width: 100%
#| layout-ncol: 2
#| fig-width: 5
normals <- tibble(
  x = c(rnorm(100000, mean = 0, sd = 1), rnorm(100000, mean = 19, sd = 4)),
  group = c(rep(1, 100000), rep(2, 100000))
)

ggplot(normals |> filter(group == 1), aes(x = x)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, color="white") +
  geom_function(fun = dnorm, args = list(mean = 0, sd = 1), color = IMSCOL["blue", "full"], size = 1) +
  labs(y = NULL, x = NULL) +
  scale_x_continuous(breaks = -3:3) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

ggplot(normals |> filter(group == 2), aes(x = x)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, fill = IMSCOL["green", "full"], color="white") +
  geom_function(
    fun = dnorm, args = list(mean = 19, sd = 4), color = IMSCOL["green", "full"], size = 1,
    linetype = "dashed"
  ) +
  labs(y = NULL, x = NULL) +
  scale_x_continuous(breaks = 19 + 4 * (-3:3)) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )
```

. . .

Las dos distribuciones entonces se escribir칤an $N(1,0)$ y $N(19,4)$.

## Ejemplo: SAT vs. ACT {.medium}

- Las puntuaciones del SAT siguen una distribuci칩n aproximadamente normal con una media de 1500 puntos y una desviaci칩n est치ndar de 300 puntos. 

$$SAT \sim N(1500,300)$$

- Las puntuaciones del ACT tambi칠n siguen una distribuci칩n aproximadamente normal con una media de 21 puntos y una desviaci칩n est치ndar de 5 puntos. 

$$ACT \sim N(21,5)$$




## Ejemplo: SAT vs. ACT {.medium}

Supongamos que una universidad est치 decidiendo cu치l de los dos aspirantes obtuvo un mejor puntaje en su examen estandarizado en comparaci칩n con los otros estudiantes: Pam, quien obtuvo un 1800 en su SAT, o Jim, quien obtuvo un 24 en su ACT?

```{r}
#| echo: false
#| fig-asp: 0.5
#| fig-align: center

sat_mean <- 1500
sat_sd <- 300
act_mean <- 21
act_sd <- 5

tests <- tibble(
  score = c(rnorm(100000, mean = sat_mean, sd = sat_sd), rnorm(100000, mean = act_mean, sd = act_sd)),
  test  = c(rep("SAT", 100000), rep("ACT", 100000))
)

p_sat <- ggplot(tests |> filter(test == "SAT"), aes(x = score)) +
  geom_function(fun = dnorm, args = list(mean = sat_mean, sd = sat_sd), color = IMSCOL["black", "full"]) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = sat_mean + sat_sd * (-3:3)) +
  annotate("segment",
    x = 1800, xend = 1800, y = 0, yend = 0.001,
    color = "darkred", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = sat_mean - 4 * sat_sd, xend = sat_mean + 4 * sat_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 1800, y = 0.0011, label = "Pam", color = "darkred") +
  coord_cartesian(xlim = sat_mean + c(-1, 1) * 4 * sat_sd)

p_act <- ggplot(tests |> filter(test == "ACT"), aes(x = score)) +
  geom_function(
    fun = dnorm, args = list(mean = act_mean, sd = act_sd),
    color = IMSCOL["black", "full"]
  ) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = act_mean + act_sd * (-3:3)) +
  annotate("segment",
    x = 24, xend = 24, y = 0, yend = 0.075,
    color = "darkblue", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = act_mean - 4 * act_sd, xend = act_mean + 4 * act_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 24, y = 0.08, label = "Jim", color = "darkblue") +
  coord_cartesian(xlim = act_mean + c(-1, 1) * 4 * act_sd)

p_sat + p_act
```


## Estandarizar con el Z-Score {.medium}

Dado que no podemos simplemente comparar estos dos puntajes, en su lugar comparamos cu치ntas desviaciones est치ndar por encima de la media est치 cada observaci칩n.

- El puntaje de Pam es $\dfrac{1800-1500}{300}=1$ desviaci칩n est치ndar (SD) encima de la media 

- El puntaje de Jim es $\dfrac{24-21}{5}=0.6$ SD encima de la media




## Estandarizar con el Z-Score {.medium}

La siguiente gr치fica visualiza la comparaci칩n que estamos haciendo al usar desviaciones est치ndar:

```{r}
#| echo: false
#| fig-asp: 0.5
#| fig-align: center

sat_mean <- 0
sat_sd <- 1
act_mean <- 0
act_sd <- 1

tests <- tibble(
  score = c(rnorm(100000, mean = sat_mean, sd = sat_sd), rnorm(100000, mean = act_mean, sd = act_sd)),
  test  = c(rep("SAT", 100000), rep("ACT", 100000))
)

p_sat <- ggplot(tests |> filter(test == "SAT"), aes(x = score)) +
  geom_function(fun = dnorm, args = list(mean = sat_mean, sd = sat_sd), color = IMSCOL["black", "full"]) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = sat_mean + sat_sd * (-3:3)) +
  annotate("segment",
    x = 1, xend = 1, y = 0, yend = 0.3,
    color = "darkred", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = sat_mean - 4 * sat_sd, xend = sat_mean + 4 * sat_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 1, y = 0.33, label = "Pam", color = "darkred") +
  annotate("segment",
    x = 0.6, xend = 0.6, y = 0, yend = 0.38,
    color = "darkblue", linetype = "dashed", size = 1
  )  +
  annotate("text", x = 0.6, y = 0.4, label = "Jim", color = "darkblue") +
  coord_cartesian(xlim = sat_mean + c(-1, 1) * 4 * sat_sd) 
p_sat
```


## El Z-score {.medium}

El Z-score de una observaci칩n representa cu치ntas desviaciones est치ndar se encuentra por encima o por debajo de la media, permitiendo comparar su posici칩n relativa dentro de una distribuci칩n.

Si $x$ es una observaci칩n de la distribuci칩n $N(\mu,\sigma)$, el Z-score se define:

$$Z=\dfrac{x-\mu}{\sigma}$$

. . . 

Observaciones que est칠n m치s all치 de $3$ SD de la media ($|Z|>3$) son usualmente consideradas inusuales.

## Maneras de detectar *Outliers* {.medium}

- $1.5 \times RIC$

- Observaciones con $|Z|>3$

- Histogramas

- Diagramas de caja

## 游눩 Ejercicio 3  {.medium}

1. Completen el siguiente c칩digo que crea una variable igual a 1 si el credito est치 fuera del rango $1.5 \times RIC$ y 0 en caso contrario.

```{r}
#| echo: true
#| eval: false
# fivenum() devuelve: min, Q1, mediana, Q3, max
q1 <- fivenum(credit$limit_bal, na.rm = TRUE)[_]
q3 <- fivenum(________________, na.rm = TRUE)[4]
ric <- q3-q1

credit <- credit |> 
  mutate(
    # Identificar outliers por RIC
    outlier_ric = ifelse(limit_bal < (q1 - 1.5 * ___) | _________ > (q3 + 1.5 * ric), 1, 0),
  ) 
```

## 游눩 Ejercicio 3  {.medium}


2. Completen el siguiente c칩digo que crea una variable igual a 1 si $|ZScore_i|>3$ y 0 en caso contrario.

```{r}
#| echo: true
#| eval: false
credit <- credit |> 
  mutate(
    z_score = (limit_bal - mean(_______, na.rm = TRUE)) / sd(_______, na.rm = TRUE),
    outlier_zscore = ifelse(abs(_______) > 3, 1, 0)
  )
```

. . .

3. Luego ejecuten el siguiente c칩digo. 쯈u칠 tan diferentes son los dos criterios?

```{r}
#| echo: true
#| eval: false
credit |> 
  count(outlier_zscore, outlier_ric)
```




## Distribuci칩n Normal y Probabilidad {.medium}

Si $X$ sigue una distribuci칩n normal, para encontrar probabilidades sobre $X$ se calculan 치reas bajo la curva normal $N(\mu,\sigma)$

![](img/normal_prob.png){height="350" fig-align="center"}


## Calculando Probabilidades: La tabla de la Normal {.medium}

$$P(Z<{\color{orange} z})=P(Z<-0.83)=0.2033$$


![](img/normal_table.png){height="450" fig-align="center"}

## Calculando Probabilidades en R {.medium}

- Con la funci칩n `pnorm()` pueden calcular probabilidades en R:


```{r}
#| echo: true
pnorm(-0.83)
```

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 0, s = 1, L = -0.83, col = IMSCOL["blue", "full"])
```

## Calculando Probabilidades en R {.medium}

Hay dos maneras de calcular probabilidades en la parte superior de la distribuci칩n:


::::: {.columns}

:::: {.column width="50%"}

- P($Z>-0.83$) = $1$ - P($Z<-0.83$)


```{r}
#| echo: true
1 - pnorm(-0.83)
```

- Y la otra es cambiando las opciones de la funci칩n:

```{r}
#| echo: true
 pnorm(-0.83, lower.tail=FALSE)
```

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 0, s = 1, U = -0.83, col = IMSCOL["blue", "full"])
```
::::

:::::



## Calculando probabilidades para la Normal {.medium}

쯈u칠 porcentaje de estudiantes tiene puntajes mayores a 1630 en el SAT? Recuerden que SAT$\sim N(1500,300)$

. . .

```{r}
#| fig-align: center
#| fig-width: 7
#| fig-height: 6
#| echo: false
par(mar = c(2, 0, 0, 0))
par_og <- par(no.readonly = TRUE) # save original par
par(mar = c(0, 0, 0, 0), mfrow = c(2, 1))

normTail(m = 1500, s = 300, U = 1630, col = IMSCOL["blue", "full"])
```


## Calculando probabilidades para la Normal {.medium}
### Probabilidades con 츼rea Complementaria


::::: {.columns}

:::: {.column width="40%"}

1. Calcular el Z-score:

$$Z=\dfrac{1630-1500}{300}=0.43$$

2. Calcular el 치rea bajo la distribuci칩n normal estandarizada:

```{r}
#| echo: true
pnorm(0.43)
 1 - pnorm(0.43)
```




::::

:::: {.column  width="60%"}

```{r}
#| fig-align: center
#| fig-width: 7
#| fig-height: 5
#| echo: false
X <- seq(-3.2, 3.2, 0.01)
Y <- dnorm(X)
plot(X, Y, type = "l", axes = F, xlim = c(-3.4, 16 + 3.4), ylim = c(0, 0.652), xlab = NA, ylab = NA)
lines(X, rep(0, length(X)))
these <- which(X <= 8)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]), c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X, Y)
# abline(h=0)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
lines(c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
text(0, 0.45, format(c(1, 0.0001), scientific = FALSE, digits = 4)[1], cex = 1)
lines(X + 8, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 8, rep(0, length(X)))
these <- which(X <= 0.43)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8, Y)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
lines(8 + c(3, 8 - 3), c(0.23, 0.23), lwd = 3)
lines(8 + c(3, 8 - 3), c(0.17, 0.17), lwd = 3)
lines(c(3.72, 4.28), rep(0.45, 2), lwd = 2)
text(8, 0.45, format(0.6664, scientific = FALSE, digits = 4)[1], cex = 1)
lines(X + 8 + 8, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 8 + 8, rep(0, length(X)))
these <- which(X > 0.43)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8 + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8 + 8, Y)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
text(12, 0.45, "=", cex = 1.5)
text(16, 0.45, format(0.3336, scientific = FALSE, digits = 4)[1], cex = 1)
par(par_og) # restore original par
```

::::

:::::


## Calculando probabilidades para la Normal {.medium}
### Usando las opciones de pnorm()

::::: {.columns}

:::: {.column width="50%"}

1. Modificar los valores en la funci칩n `pnorm()`:

```{r}
#| echo: true
pnorm(1630,
      mean = 1500,
      sd = 300,
      lower.tail=FALSE)
```

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 1500, s = 300, U = 1630, col = IMSCOL["blue", "full"])
```
::::

:::::




## Calculando probabilidades: Otro ejemplo {.medium}

Con base en una muestra de 100 transacciones, el gasto promedio mensual de los clientes en una tienda minorista estadounidense sigue una distribuci칩n casi normal con una media de $70.00 y una desviaci칩n est치ndar de $3.30. 쮺u치l es la probabilidad de seleccionar aleatoriamente una transacci칩n entre 69 y 74 d칩lares?

. . .

```{r}
#| fig-asp: 0.4
#| out-width: 60%
#| fig-align: center
#| fig-width: 5
#| echo: false
par(mar = c(2, 0, 0, 0))
normTail(70, 3.3, M = c(69, 74), col = IMSCOL["blue", "full"])
```


## Calculando probabilidades: Otro ejemplo {.medium}

```{r}
#| fig-asp: 0.25
#| fig-align: center
#| out-width: 100%
#| echo: false
X <- seq(-3.2, 3.2, 0.01)
Y <- dnorm(X)
par(mar = c(2, 0, 0, 0))
plot(X, Y, type = "l", axes = F, xlim = c(-3.4, 24 + 3.4), ylim = c(0, 0.6), xlab = NA, ylab = NA)
lines(X, rep(0, length(X)))
these <- which(X <= 8)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]), c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X, Y)
lines(c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
lines(X + 8, Y, type = "l")
lines(X + 8, rep(0, length(X)))
these <- which(X < -0.303)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8, Y)
lines(8 + c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
lines(X + 16, Y, type = "l")
lines(X + 16, rep(0, length(X)))
these <- which(X > 1.212)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 16, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 16, Y)
lines(16 + c(3, 8 - 3), c(0.23, 0.23), lwd = 3)
lines(16 + c(3, 8 - 3), c(0.17, 0.17), lwd = 3)
lines(X + 24, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 24, rep(0, length(X)))
these <- which(X > -0.303 & X < 1.212)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 24, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 24, Y)
text(0, 0.53, "1.0000")
text(8, 0.53, "0.3820")
text(16, 0.53, "0.1131")
text(24, 0.53, "0.5047")
```

::::: {.columns}

:::: {.column .fragment width="50%"}

$$Z_1=\dfrac{69-70}{3.3}=-0.30$$

$$Z_2=\dfrac{74-70}{3.3}=1.21$$




::::

:::: {.column .fragment width="50%"}

```{r}
#| echo: true
a <- pnorm(-0.30)
a
b <- pnorm(1.21, lower.tail=FALSE)
b
1-a-b
```
::::

:::::


## Calculando cuartiles/percentiles {.medium}

쯈u칠 valor en la distribuci칩n de transacciones es el primer cuartil ($Q_1$)? Recuerden que 25% de los datos son menores al primer cuartil.

```{r}
#| fig-asp: 0.4
#| out-width: 60%
#| fig-align: center
#| fig-width: 5
#| echo: false
par(mar = c(2, 0, 0, 0))
normTail(70, 3.3, L = qnorm(0.25, 70, 3.3), col = IMSCOL["blue", "full"])
text(66.5, 0.03, "25%\n(0.25)", cex = 1, col = IMSCOL["black", "full"])
```

## Calculando cuartiles/percentiles en R {.medium}

La funci칩n `qnorm()` permite calcular cuartiles/percentiles para una distribuci칩n normal:

```{r}
#| echo: true
qnorm(0.25, mean = 0, sd = 1)
```

. . .

Sabiendo que el primer cuartil en la distribuci칩n normal estandarizada es $Z_{Q_1}=-0.674$:


$$ -0.674 = Z_{Q_1} = \frac{x_{Q_1} - \mu}{\sigma} = \frac{x_{Q_1} - 70}{3.3} $$
Resolviendo para $Z_{Q_1}$, se encuentra que 67.7 d칩lares es el primer cuartil en la distribuci칩n original.

## Calculando cuartiles/percentiles en R {.medium}

Al usar las opciones de la funci칩n `qnorm()`, podemos calcular el valor exacto del primer cuartil:

```{r}
#| echo: true
qnorm(0.25, mean = 70, sd = 3.3)
```

. . .

### 쯈u칠 es un percentil?

- Es un valor que divide un conjunto de datos ordenados en 100 partes iguales, indicando la posici칩n relativa de un dato dentro del conjunto

- Por ejemplo, el primer cuartil es equivalente al percentil 25, lo que significa que el 25% de los datos son menores o iguales a ese valor


## La regla 68-95-99.7 {.medium}


```{r}
#| echo: false
#| fig-height: 5
#| fig-width: 8
#| fig-align: center

par(mar = c(2, 0, 0, 0))
X <- seq(-4, 4, 0.01)
Y <- dnorm(X)
plot(X, Y, type = "n", axes = F, ylim = c(0, 0.4), xlim = c(-3.2, 3.2), xlab = NA, ylab = NA)
abline(h = 0, col = IMSCOL["black", "full"])
axis(1, at = -3:3, label = expression(
  mu - 3 * sigma, mu - 2 * sigma, mu - sigma, mu,
  mu + sigma, mu + 2 * sigma, mu + 3 * sigma
))
ii <- c(1, 2, 3)
jj <- c(1, 1, 1)
for (i in 3:1) {
  these <- (X >= i - 1 & X <= i)
  polygon(c(i - 1, X[these], i), c(0, Y[these], 0), col = IMSCOL[ii[i], jj[i]], border = IMSCOL[ii[i], jj[i]])
  these <- (X >= -i & X <= -i + 1)
  polygon(c(-i, X[these], -i + 1), c(0, Y[these], 0), col = IMSCOL[ii[i], jj[i]], border = IMSCOL[ii[i], jj[i]])
}
# ===> label 99.7 <===#
arrows(-3, 0.03, 3, 0.03, code = 3, col = "#444444", length = 0.15)
text(0, 0.02, "99.7%", pos = 3)
# ===> label 95 <===#
arrows(-2, 0.13, 2, 0.13, code = 3, col = "#444444", length = 0.15)
text(0, 0.12, "95%", pos = 3)
# ===> label 68 <===#
arrows(-1, 0.23, 1, 0.23, code = 3, col = "#444444", length = 0.15)
text(0, 0.22, "68%", pos = 3)
lines(X, Y, col = "#888888")
abline(h = 0, col = "#AAAAAA")
```

. . . 

```{r}
#| echo: true
pnorm(1) - pnorm(-1)
pnorm(2) - pnorm(-2)
pnorm(3) - pnorm(-3)
```


## 游눩 Ejercicio 4  {.medium}


1. Suponga que el l칤mite de cr칠dito `limit_bal`$\sim N(150000,50000)$. Calcule de dos maneras diferentes la probabilidad de que un cliente seleccionado al azar tenga un l칤mite de cr칠dito superior a 240000.

2. Encuentren el l칤mite de cr칠dito que corresponde al percentil 95.


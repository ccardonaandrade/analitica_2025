---
title: Analítica de los Negocios
author: Carlos Cardona Andrade
subtitle: Explorando datos categóricos
execute:
  freeze: auto
  echo: true
  fig-width: 6
  fig-height: 5
format:
  revealjs: 
   theme: ../slides.scss
   header-includes: |
      <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet"/>
   slide-number: true
   show-slide-number: all
   transition: fade
   progress: true
   multiplex: false
   scrollable: false
   preview-links: false
   hide-inactive-cursor: true
   highlight-style: printing
   pause: true
---
     
```{r}
#| eval: true
#| echo: false
library(knitr)
library(forcats)
library(patchwork)
library(lubridate)
library(cowplot)
library(tidyverse)
library(kableExtra)
library(openintro)
library(janitor)
library(ggrepel)
library(waffle)
library(ggmosaic)
```


## Plan para hoy

1. [Datos categóricos](#intro)

2. [Visualizandos una variable categórica](#1category)

3. [Visualizandos dos variables categóricas](#2categories)

4. [Comparando variables numéricas entre grupos](#acrossgroups)

5. [Probabilidad](#probabilidad)

6. [La Distribución Normal](#distnormal)


# Datos categóricos {#intro}

## Tipos de variables

```{r}
#| echo: false
#| fig-align: center

par_og <- par(no.readonly = TRUE) # save original par
par(mar = rep(0, 4))
plot(c(-0.15, 1.3), 0:1, type = "n", axes = FALSE)

text(0.6, 0.9, "Variables")
rect(0.4, 0.8, 0.8, 1)

text(0.25, 0.5, "Numéricas")
rect(0.1, 0.4, 0.4, 0.6)
arrows(0.45, 0.78, 0.34, 0.62, length = 0.08)

text(0.9, 0.5, "Categóricas")
rect(0.73, 0.4, 1.07, 0.6)
arrows(0.76, 0.78, 0.85, 0.62, length = 0.08)

text(0, 0.1, "Discretas")
rect(-0.17, 0, 0.17, 0.2)
arrows(0.13, 0.38, 0.05, 0.22, length = 0.08)

text(0.39, 0.1, "Continuas")
rect(0.25, 0, 0.53, 0.2)
arrows(0.35, 0.38, 0.4, 0.22, length = 0.08)

text(0.77, 0.105, "Ordinales")
rect(0.64, 0, 0.9, 0.2)
arrows(0.82, 0.38, 0.77, 0.22, length = 0.08)

text(1.12, 0.1, "Nominales")
rect(0.99, 0, 1.25, 0.2)
arrows(1.02, 0.38, 1.1, 0.22, length = 0.08)
par(par_og) # restore original par
```
   

## Variables Categóricas

```{r}
#| echo: false
#| fig-align: center

par_og <- par(no.readonly = TRUE) # save original par
par(mar = rep(0, 4))
plot(c(-0.15, 1.3), 0:1, type = "n", axes = FALSE)

text(0.6, 0.9, "Variables")
rect(0.4, 0.8, 0.8, 1)

text(0.25, 0.5, "Numéricas", col = "gray50")
rect(0.1, 0.4, 0.4, 0.6, border = "gray50")
arrows(0.45, 0.78, 0.34, 0.62, length = 0.08, col = "gray50")

text(0.9, 0.5, "Categóricas")
rect(0.73, 0.4, 1.07, 0.6)
arrows(0.76, 0.78, 0.85, 0.62, length = 0.08)

text(0, 0.1, "Discretas", col = "gray50")
rect(-0.17, 0, 0.17, 0.2, border = "gray50")
arrows(0.13, 0.38, 0.05, 0.22, length = 0.08, col = "gray50")

text(0.39, 0.1, "Continuas", col = "gray50")
rect(0.25, 0, 0.53, 0.2, border = "gray50")
arrows(0.35, 0.38, 0.4, 0.22, length = 0.08, col = "gray50")

text(0.77, 0.105, "Ordinales")
rect(0.64, 0, 0.9, 0.2)
arrows(0.82, 0.38, 0.77, 0.22, length = 0.08)

text(1.12, 0.1, "Nominales")
rect(0.99, 0, 1.25, 0.2)
arrows(1.02, 0.38, 1.1, 0.22, length = 0.08)
par(par_og) # restore original par
```

```{r}
#| echo: false
loans <- loans_full_schema |>
  mutate(application_type = as.character(application_type)) |>
  filter(application_type != "") |>
  mutate(
    homeownership = tolower(homeownership),
    homeownership = fct_relevel(homeownership, "rent", "mortgage", "own"),
    application_type = fct_relevel(application_type, "joint", "individual")
  )

loans_individual_rent <- loans |>
  filter(
    application_type == "individual",
    homeownership == "rent"
  ) |>
  nrow()
```


# Visualizandos una variable categórica {#1category}



## Tabla de Frecuencia {.medium}

- Una variable categórica se resume mediante una tabla que muestra la [frecuencia]{.hl .hl-blue} o el [porcentaje]{.hl .hl-blue} de casos en cada categoría

- Suele representarse mediante un gráfico de barras o un gráfico de torta

<br>

::: {.tbl-classic .tbl-larger}

```{r}
#| echo: false
#| fig-align: center
loans |>
  count(homeownership, name = "Frequency") |>
  adorn_totals(where = "row") |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(
    bootstrap_options = c("striped", "condensed"),
    latex_options = c("striped"), full_width = FALSE
  ) |>
  column_spec(1:2, width = "10em")
```

:::

## Gráfico de barras {.medium}

::: columns
::: {.column width="50%"}

Un gráfico de barras es la forma más común de representar una única variable categórica. 

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```
:::
:::

## Gráfico de barras {.medium}

::: columns
::: {.column width="50%"}

Un gráfico de barras en el que se muestran proporciones en lugar de frecuencias se llama gráfico de barras de frecuencia relativa.
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```
:::
:::


## Gráfico de barras en R

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1|2|3,4|5"

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership",
       y = "Frequency") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```
:::
:::


## Gráfico de barras en R {.medium}


::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1,2,3|4,5|6|7,8|9"

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership,
             y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership",
       y = "Proportion") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```
:::
:::

## Gráfico de barras

```{r}
#| echo: false
#| fig-subcap:
#|   - Counts of homeownership.
#|   - Proportions of homeownership.
#| fig-width: 5
#| layout-ncol: 2
ggplot(loans, aes(x = homeownership)) +
  geom_bar(fill = "gold") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()

loans |>
  count(homeownership) |>
  mutate(proportion = n / sum(n)) |>
  ggplot(aes(x = homeownership, y = proportion)) +
  geom_col(fill = "gold") +
  labs(x = "Homeownership", y = "Proportion") +
  theme_minimal()
```


## 💪 Ejercicio 1  {.medium}

1. Usando la plantilla con la que ya hemos trabajado anteriormente, establezcan el directorio de trabajo y carguen los paquetes `tidyverse` y `janitor` (Este último instálenlo por lo que es la primera vez que lo usamos).

2. Importen los datos `credit_demographics` con el nombre `credit` usando la función `read.csv()`.

3. Exploren los datos usando la función `glimpse()`.

4. En ocasiones, algunos nombres de variables pueden ser inconsistentes o difíciles de manejar. El paquete `janitor` facilita este proceso. Ejecuten la siguiente línea de código y luego vuelvan a utilizar la función `glimpse()`. ¿Notan la diferencia en los nombres?

```{r}
#| eval: false
credit <- credit |>
  clean_names()
```


## 💪 Ejercicio 1  {.medium}

5. Como pueden notar en el punto anterior, la variable `default` contiene 0s y 1s. Vamos a convertirla en una variable de texto (`string`) para que sea más fácil de interpretar en los gráficos. Ejecuten el siguiente código para crear una nueva variable:

```{r}
#| eval: false
credit <- credit |>
  mutate(
    default_string = case_when(
      default == 1 ~ "Default",
      default == 0 ~ "No Default",
      TRUE ~ NA_character_  # Assign NA for any unmatched values
    ))
```

6. Usando esta nueva variable `default_string` y el paquete `ggplot`, construyan un gráfico de barras para visualizar cuántos clientes están en *default* y cuántos no. Asegúrense de incluir etiquetas y un título para hacer el gráfico más informativo.




## Gráficos de torta {.medium}

::: columns
::: {.column width="50%"}

- Las áreas de las porciones representan los porcentajes de las categorías

- Generalmente es más difícil comparar los tamaños de los grupos en un gráfico de pastel que en un gráfico de barras
:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  count(homeownership) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = homeownership, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(aes(x = 1, label = homeownership, y = text_y)) +
  coord_polar("y", start = 0) +
  scale_fill_openintro("hot") +
  theme_void() +
  labs(title = "Homeownership")
```
:::
:::

## Gráficos de torta {.medium}



```{r}
#| echo: false
#| fig-subcap: 
#|   - Pie chart
#|   - Bar plot
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  count(homeownership) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = homeownership, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(aes(x = 1, label = homeownership, y = text_y)) +
  coord_polar("y", start = 0) +
  scale_fill_openintro("hot") +
  theme_void() +
  labs(title = "Homeownership")

loans |>
  mutate(homeownership = fct_infreq(homeownership)) |>
  ggplot(aes(x = homeownership, fill = homeownership)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_openintro("hot") +
  labs(x = "Homeownership", y = "Frequency") +
  theme_minimal()
```


## Gráficos de torta {.medium}


::: columns
::: {.column width="50%"}

- Es mucho más fácil hacer un gráfico de pastel incorrecto que un gráfico de barras incorrecto.

- En un gráfico de pastel, las categorías deben representar un todo. No existe esta restricción para un gráfico de barras.

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5
loans |>
  count(grade) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = grade, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(
    aes(x = 1.4, label = grade, y = text_y), nudge_x = 0.3, segment.size = 0.5
  ) +
  coord_polar(theta = "y") +
  scale_fill_openintro("cool") +
  theme_void() +
  labs(title = "Loan grade")
```
:::
:::


## Gráficos de torta {.medium}



```{r}
#| echo: false
#| fig-subcap: 
#|   - Pie chart
#|   - Bar plot
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
loans |>
  count(grade) |>
  mutate(text_y = cumsum(n) - n / 2) |>
  ggplot(aes(x = "", fill = grade, y = n)) +
  geom_col(position = position_stack(reverse = TRUE), show.legend = FALSE) +
  geom_text_repel(
    aes(x = 1.4, label = grade, y = text_y), nudge_x = 0.3, segment.size = 0.5
  ) +
  coord_polar(theta = "y") +
  scale_fill_openintro("cool") +
  theme_void() +
  labs(title = "Loan grade")

loans |>
  ggplot(aes(x = grade, fill = grade)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_openintro("cool") +
  labs(x = "Loan grade", y = "Frequency") + 
  theme_minimal()
```


## Gráfico de torta en R {.medium}

::: columns
::: {.column width="50%"}

- Existen diferentes maneras de hacer un gráfico de torta, más allá de `ggplot`

- En [Pie Charts](https://r-graph-gallery.com/pie-plot.html){target="_blank"} encuentran una guía explicando diferentes maneras de hacerlo en <i class="fa-brands fa-r-project"></i>

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/pie-plot.html"></iframe>
```
:::
:::



## Gráfico de Waffle {.medium}

```{r}
#| echo: false
#| fig-subcap:
#|   - "Homeownership: rent, mortgage, and own"
#|   - "Loan status: fully paid, in grace period, and late"
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%

loans |>
  count(homeownership) |>
  ggplot(aes(fill = homeownership, values = n)) +
  geom_waffle(
    color = "white", flip = TRUE, make_proportional = TRUE, na.rm = TRUE
  ) +
  labs(fill = NULL, title = "Homeownership") +
  scale_fill_openintro("hot") +
  coord_equal() +
  theme_enhance_waffle() +
  theme_void() +  # Removes background, grid lines, and axis text
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 13)
  )

loans |>
  count(loan_status) |>
  ggplot(aes(fill = loan_status, values = n)) +
  geom_waffle(
    color = "white", flip = TRUE, make_proportional = TRUE, na.rm = TRUE
  ) +
  labs(fill = NULL, title = "Loan status") +
  scale_fill_openintro("four") +
  coord_equal() +
  theme_enhance_waffle() +
  theme_void() +  # Removes background, grid lines, and axis text
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 13)
  ) +
  guides(fill = guide_legend(nrow = 2))
```


## Gráfico de Waffle {.medium}

- Los gráficos de waffle son otra técnica útil para visualizar datos categóricos, mostrando la proporción de cada categoría

- Al igual que los gráficos de pastel, funcionan mejor cuando el número de categorías es bajo

- A diferencia de los gráficos de pastel, facilitan la comparación de proporciones que no representan fracciones simples



## Gráfico de Waffle en R {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de gráfico va más allá de la funcionalidad de `ggplot`

- Por lo tanto no lo explicaré en clase, pero acá les dejo recursos para que aprendan por su cuenta: 

  1. La página del paquete [waffle](https://github.com/hrbrmstr/waffle){target="_blank"}

  2. [Waffle Charts](https://r-graph-gallery.com/waffle.html){target="_blank"} provee una guía de cómo crear este tipo de gráfico

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/waffle.html" title="waffle plots"></iframe>
```
:::
:::


# Visualizandos dos variables categóricas {#2categories}


## Tablas de Contingencia {.medium}

- Una tabla que resume datos para dos variables categóricas de esta manera se llama [tabla de contingencia]{.hl .hl-blue}

- Cada valor en la tabla representa la cantidad de veces que ocurrió una combinación particular de resultados de las variables

<br>

::: {.tbl-classic .tbl-larger}

```{r}
#| echo: false
#| fig-align: center

loans |>
  count(application_type, homeownership) |>
  pivot_wider(names_from = homeownership, values_from = n) |>
  select(application_type, rent, mortgage, own) |>
  adorn_totals(where = c("row", "col")) |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(
    bootstrap_options = c("striped", "condensed"),
    latex_options = c("striped")
  ) |>
  add_header_above(c(" " = 1, "homeownership" = 3, " " = 1)) |>
  column_spec(1, width = "8em") |>
  column_spec(2:5, width = "5em")
```

:::

## Gráfico de barras apiladas {.medium}

::: columns
::: {.column width="50%"}

- Los solicitantes de préstamos viven más comúnmente en viviendas con hipoteca

- Sin embargo, basándose solo en este gráfico, es difícil determinar cómo varían los tipos de solicitud entre los niveles de tenencia de vivienda

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gráfico de barras estandarizado {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de visualización es útil para comprender la proporción del tipo de solicitudes en cada nivel de tenencia de vivienda

- Además, dado que las proporciones del tipo de préstamos varían entre los grupos, podemos concluir que estas dos variables están asociadas en esta muestra


:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gráfico de barras dobles {.medium}

::: columns
::: {.column width="50%"}

- Dentro de cada nivel de tenencia de vivienda, las solicitudes individuales son más comunes que las solicitudes conjuntas

- Las solicitudes conjuntas son más comunes entre los solicitantes con hipoteca, en comparación con los inquilinos y los propietarios.

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::



## Gráfico de barras apiladas en R

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "1,2|3|4,5|6,7,8"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar() +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gráfico de barras estandarizado en R {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "3|1,2,3,4,5,6,7,8,9"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Gráfico de barras dobles en R {.medium}

::: columns
::: {.column width="50%"}

```{r}
#| echo: true
#| eval: false
#| fig-width: 5
#| code-line-numbers: "3|1,2,3,4,5,6,7,8,9"

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| fig-width: 5

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()
```
:::
:::


## Explorando dos variables categóricas

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 2.5
#| fig-height: 2.5
#| layout: [[50, 50], [-22, 56, -22]]
ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(show.legend = FALSE) +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal()

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "fill", show.legend = FALSE) +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Proportion",
       fill = "Application type") +
  theme_minimal()

ggplot(loans, aes(x = homeownership,
                  fill = application_type)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("darkred",
                               "gold")) +
  labs(x = "Homeownership",
       y = "Frequency",
       fill = "Application type") +
  theme_minimal() +
  theme(legend.position = "bottom")
```


## 💪 Ejercicio 2  {.medium}

1. Con base en el código con el que crearon la variable `default_string`, generen la variable `marriage_string` según los valores de la variable `marriage`:

   - 1 $\rightarrow$ *married*
  
   - 2 $\rightarrow$ *single* 
   
   - 3 $\rightarrow$ *other*

2. Creen un gráfico de barras (apilados, dobles o estandarizado) para visualizar la relación entre el estado civil (`marriage_string`) y si el cliente está en default (`default_string`).

3. ¿Qué pueden concluir a partir del gráfico anterior?



## Gráfico de mosaico

```{r}
#| echo: false
#| fig-subcap: 
#|   - Homeownership.
#|   - Homeownership vs. application type.
#| layout: [[46, -6, 46]]
#| fig-width: 5
#| out-width: 100%
ggplot(loans) +
  geom_mosaic(aes(x = product(homeownership)), fill = IMSCOL["green", "full"]) +
  labs(x = "Homeownership", y = "") +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) + 
  theme(
    panel.background = element_rect(fill = "white", color = NA),  # Remove grey background
    plot.background = element_rect(fill = "white", color = NA),   # Remove grey plot background
    panel.grid = element_blank(),  # Remove grid lines
    axis.title = element_text(size = 12),  # Keep axis labels
    axis.text = element_text(size = 10)    # Keep axis text
  )

ggplot(loans) +
  geom_mosaic(aes(x = product(homeownership), fill = application_type)) +
  scale_fill_manual(values = c(IMSCOL["blue", "full"], IMSCOL["yellow", "full"])) +
  labs(x = "Homeownership", y = "Application type") +
  guides(fill = FALSE) + 
  theme_mosaic()   # Removes background, grid lines, and axis text

```

## Gráfico de mosaico {.medium}

- Un gráfico mosaico es otra manera de visualizar tablas de contingencia que se asemeja a un gráfico de barras apiladas estandarizado

- La ventaja consiste en aún poder ver el tamaño relativo de los grupos de la variable principal

. . . 

$$
\small
\begin{array}{rcl}
\text{Area del segmento} &=& (\text{ancho de la barra}) \times (\text{longitud del segmento}) \\  
&=& \text{frecuencia de la fila} \times (\text{proporcion de la fila}) \\  
&=& \text{frecuencia de la fila} \times \dfrac{\text{frecuencia de la celda}}{\text{frecuencia de la fila}} \\  
&=& \text{frecuencia de la celda}  
\end{array}
$$

## Gráfico de mosaico {.medium}

Es importante pensar cuál variable va en el eje horizontal y cuál en el vertical. En ocasiones, una es más *explicativa* que la otra.

```{r}
#| echo: false
#| fig-width: 10
#| fig-align: center
#| out-width: 100%
ggplot(loans) +
  geom_mosaic(aes(x = product(application_type), fill = homeownership)) +
  scale_fill_openintro("hot") +
  labs(x = "Application type", y = "Homeownership") +
  guides(fill = FALSE) + 
  theme_mosaic()
```


## Gráfico de Mosaico en R {.medium}

::: columns
::: {.column width="50%"}

- Este tipo de gráfico también va más allá de la funcionalidad de `ggplot`

- La página del paquete [ggmosaic](https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html){target="_blank"} es un buen sitio para empezar a practicar por su cuenta


:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html" title="waffle plots"></iframe>
```
:::
:::

# Comparando variables numéricas entre grupos {#acrossgroups}

## Histograma y Diagrama de Caja entre grupos {.medium}


```{r}
#| echo: false
#| out-width: 100%
#| fig-asp: 0.23
#| fig-align: center
library(gapminder)
gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot() +
  geom_histogram(aes(x=lifeExp, fill=continent), alpha = 0.5, bins=10) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       fill = "Continent") +
  theme_minimal()

gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot() +
  geom_boxplot(aes(x=lifeExp, y=continent, color=continent)) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       color = "Continent") +
  theme_minimal()
```


## Ridge plot {.medium}

Otro tipo de visualización útil para comparar datos numéricos entre grupos es el gráfico de crestas (ridge plot), que combina gráficos de densidad de varios grupos en la misma escala dentro de una única ventana de visualización


```{r}
#| echo: false
#| out-width: 100%
#| fig-asp: 0.23
#| fig-align: center
library(ggridges)
gapminder |> 
  filter(continent %in% c("Africa", "Americas")) |>
ggplot(aes(x=lifeExp, y=continent, color=continent, fill=continent)) +
  geom_density_ridges(alpha = 0.5) +
   labs(y = NULL,
       x = "Life Expectancy (years)",
       color = "Continent",
       fill = "Continent") +
  theme_minimal()
```


## Ridge plot {.medium}

Establecer el color según la variable numérica en lugar de la categórica puede ser bastante útil para contar la historia de los datos.


```{r}
#| echo: false
#| out-width: 100%
#| fig-align: center
library(viridis)
library(hrbrthemes)

gapminder |>
  filter(year %in% c(1952, 1962, 1972, 1982, 1992, 2002)) |>
ggplot(aes(x = lifeExp, y = factor(year), fill = stat(x))) +
  geom_density_ridges_gradient() +
  scale_fill_viridis_c(name = "Life Expectancy (years)", option = "C")+
  labs(y = "Year",
       x = "Life Expectancy (years)") + 
  theme_ipsum() +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      strip.text.x = element_text(size = 8)
    )

```


## Ridge plot en R {.medium}

::: columns
::: {.column width="50%"}

- Quiero destacar la flexibilidad de <i class="fa-brands fa-r-project"></i> para mejorar con la incorporación de paquetes

- La página del paquete [ggridges](https://haleyjeppson.github.io/ggmosaic/articles/ggmosaic.html){target="_blank"} es un buen sitio para profundizar en este tipo de gráfico

- [Basic ridgeline plot](https://r-graph-gallery.com/294-basic-ridgeline-plot.html){target="_blank"} también explica este gráfico y tiene buenos ejemplos

:::

::: {.column width="50%"}
```{=html}
<iframe width=600 height=375 src="https://r-graph-gallery.com/294-basic-ridgeline-plot.html" title="ridge plots"></iframe>
```
:::
:::


## Maneras de visualizar relaciones entre variables {.medium}

- numérica v.s. numérica
  
    - Diagramas de dispersión
    
    
- categórica v.s. categórica

    - Tablas de contigencia
    - Gráficos de barra (apilados, dobles, estandarizados)
    - Gráfico de mosaico
    
- categórica v.s. numérica
 
    - Diagramas de caja entre grupos
    - Ridge plots
    
# Probabilidad {#probabilidad}

## Probabilidad {.medium}

- Una probabilidad se define como la siguiente proporción:

$$P=\dfrac{\#\, \text{resultados deseados}}{\#\, \text{resultados posibles}}$$

- Por ejemplo, al tirar un dado la probabilidad de obtener un 2 luego de lanzar un dado es:

$$P(2)=\dfrac{1}{6}=0.166=16.66\%$$

## Probabilidad {.medium}

1. Las probabilidades siempre están entre 0 y 1.
  - Una probabilidad igual a 0 indica que el evento nunca va a ocurrir. 
  - Por otro lado, si es igual a 1 indica que con toda seguridad el evento tendrá lugar.
  
2. $\sum{P}=1$
3. La probabilidad de que un evento **no ocurra** es igual a 1 menos la probabilidad de que el evento ocurra.
  - Al tirar un dado:
  
$$P(\sim2)=1-P(2)=1-\dfrac{1}{6}=\dfrac{5}{6}$$

## Probabilidad {.medium}

4. Si A y B son eventos alternativos (no se superponen), entonces $P(A$ $o$ $B)=P(A)+P(B)$
  - Siguiendo con el ejemplo del dado:
  
$$P(2\, o\,  3)=P(2)+P(3)=\dfrac{1}{6}+\dfrac{1}{6}=\dfrac{2}{6}=\dfrac{1}{3}$$

## Probabilidad {.medium}

5. Si A y B son eventos que se superponen (ocurrencia conjunta), entonces $P(A$ $o$ $B)=P(A)+P(B)-P(A$ $y$ $B)$
  - ¿Cuál sería la probabilidad de sacar un número par o un 6?
  
$$P(Par\, o\,  6)=P(Par)+P(6)=\dfrac{3}{6}+\dfrac{1}{6}=\dfrac{4}{6}=\dfrac{2}{3} \quad \text{Incorrecto} $$

$$P(Par\, o\,  6)=P(Par)+P(6)-P(Par\, y\,  6)=\dfrac{3}{6}+\dfrac{1}{6}-\dfrac{1}{6}=\dfrac{3}{6}=\dfrac{1}{2} \quad \text{Correcto} $$

## Probabilidad {.medium}

6. Si A y B son **independientes**, entonces $P(A\, y\, B)=P(A) \cdot P(B)$
  - ¿Cuál es la probabilidad de sacar 2 luego de tirar el dado dos veces?
  
$$P(2\, luego\, 2)=P(2) \cdot P(2)=\dfrac{1}{6} \cdot \dfrac{1}{6}=\dfrac{1}{36}$$

## Probabilidad {.medium}

- Es importante tener en cuenta si existe reemplazo o no.
- Por ejemplo, si un recipiente tiene 4 pelotas amarillas y 2 azules. ¿Cuál es la probabilidad de sacar una amarilla y luego una azul sin reemplazo?

$$P(Amarilla\, luego\, Azul)=P(Amarilla) \cdot P(Azul)=\dfrac{4}{6} \cdot \dfrac{2}{5}=\dfrac{8}{30}=\dfrac{4}{15}$$

# La Distribución Normal {#distnormal}


## Escala de frecuencia de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

Retomemos la distribución de la expectativa de vida en los datos `gapminder`.

Para los histogramas en una escala de frecuencia, la altura de las barras = cantidad de observaciones en ese intervalo.

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp), 
                 color = "black", fill = "darkblue", bins = 30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  labs(x="Life Expectancy (years)",
       y="Frequency") +
  theme_minimal()

```
::::

:::::




## Escala de densidad de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

Para un histograma en una escala de densidad,  
el área de la barra = proporción de observaciones en ese intervalo. 

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                 color = "black", fill = "darkblue", bins = 30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal()

```
::::

:::::




## Escala de densidad de un Histograma {.medium}


::::: {.columns}

:::: {.column width="50%"}

En una escala de densidad, la [proporción]{.hl .hl-blue} de países con expectativas de vida entre 60 y 70 años = el [área]{.hl .hl-blue} bajo la curva del histograma entre 60 y 70

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6


gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density), 
                     fill = after_stat(x) >= 60 & after_stat(x) <= 70), 
                 color = "black", bins=30) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "darkblue")) + 
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() +
  theme(legend.position = "none")  # Hides the legend

```
::::

:::::




## Del Histograma a la Curva de Densidad {.medium}


::::: {.columns}

:::: {.column width="50%"}

Podríamos intentar aproximar un histograma mediante una curva suave, 
llamada una [función de densidad (probabilidad)]{.hl .hl-blue}.

1. Una función de densidad nunca es negativa

2. El área total bajo la curva es siempre 1 o 100%

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                     fill = "lightblue", 
                 color = "#c8d9ed", bins=30) +
  geom_density(aes(x=lifeExp), color="darkblue")+
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() 
```
::::

:::::





## Del Histograma a la Curva de Densidad {.medium}


::::: {.columns}

:::: {.column width="50%"}

Por lo tanto, la proporción de países con expectativas de vida entre 60 y 70 años se puede estimar como el [área sombreada bajo la curva]{.hl .hl-blue}. La proporción exacta es el área bajo el histograma.

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 6
#| fig-height: 6

density_data <- density(gapminder$lifeExp)
density_df <- data.frame(x = density_data$x, y = density_data$y)

gapminder |>
  ggplot() +
  geom_histogram(aes(x = lifeExp, y = after_stat(density)), 
                 fill = "lightblue", 
                 color = "#c8d9ed", bins=30) +
  geom_density(aes(x = lifeExp), color = "darkblue") +
  geom_area(data = subset(density_df, x >= 60 & x <= 70),
            aes(x = x, y = y),
            fill = "darkblue",
            alpha = 0.3) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) +
  scale_y_continuous(limits = c(0, 0.04)) +
  labs(x="Life Expectancy (years)",
       y="Density") +
  theme_minimal() 
```
::::

:::::


## Variables continuas y Curvas de densidad {.medium}

La distribución de probabilidad de una variable aleatoria continua se describe mediante una curva de densidad.  

Si $Y$ es una variable aleatoria continua, $P(a < Y < b)$ es el área bajo la curva de densidad de $Y$ sobre el intervalo entre $a$ y $b$.  

![](img/continuous.png){height="150" fig-align="center"}

. . . 

Nota: todas las distribuciones de probabilidad continuas asignan una probabilidad de cero a cada resultado individual: $P(Y=y)=0$


## Distribución Normal {.medium}

La distribución normal (campana de Gauss) es una familia de curvas de densidad que son [simétricas]{.marker-hl} y con [forma de campana]{.marker-hl}. Se definen por su media ${\color{orange} \mu}$ y su desviación estándar ${\color{orange} \sigma}$, con notación $N(\mu,\sigma)$.


```{r}
#| echo: false
#| fig-subcap:
#|   - Mean = 0, SD = 1
#|   - Mean = 19, SD = 4
#| fig-asp: 0.5
#| out-width: 100%
#| layout-ncol: 2
#| fig-width: 5
normals <- tibble(
  x = c(rnorm(100000, mean = 0, sd = 1), rnorm(100000, mean = 19, sd = 4)),
  group = c(rep(1, 100000), rep(2, 100000))
)

ggplot(normals |> filter(group == 1), aes(x = x)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, color="white") +
  geom_function(fun = dnorm, args = list(mean = 0, sd = 1), color = IMSCOL["blue", "full"], size = 1) +
  labs(y = NULL, x = NULL) +
  scale_x_continuous(breaks = -3:3) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

ggplot(normals |> filter(group == 2), aes(x = x)) +
  geom_histogram(aes(y = ..density..), alpha = 0.5, fill = IMSCOL["green", "full"], color="white") +
  geom_function(
    fun = dnorm, args = list(mean = 19, sd = 4), color = IMSCOL["green", "full"], size = 1,
    linetype = "dashed"
  ) +
  labs(y = NULL, x = NULL) +
  scale_x_continuous(breaks = 19 + 4 * (-3:3)) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )
```

. . .

Las dos distribuciones entonces se escribirían $N(1,0)$ y $N(19,4)$.

## Ejemplo: SAT vs. ACT {.medium}

- Las puntuaciones del SAT siguen una distribución aproximadamente normal con una media de 1500 puntos y una desviación estándar de 300 puntos. 

$$SAT \sim N(1500,300)$$

- Las puntuaciones del ACT también siguen una distribución aproximadamente normal con una media de 21 puntos y una desviación estándar de 5 puntos. 

$$ACT \sim N(21,5)$$




## Ejemplo: SAT vs. ACT {.medium}

Supongamos que una universidad está decidiendo cuál de los dos aspirantes obtuvo un mejor puntaje en su examen estandarizado en comparación con los otros estudiantes: Pam, quien obtuvo un 1800 en su SAT, o Jim, quien obtuvo un 24 en su ACT?

```{r}
#| echo: false
#| fig-asp: 0.5
#| fig-align: center

sat_mean <- 1500
sat_sd <- 300
act_mean <- 21
act_sd <- 5

tests <- tibble(
  score = c(rnorm(100000, mean = sat_mean, sd = sat_sd), rnorm(100000, mean = act_mean, sd = act_sd)),
  test  = c(rep("SAT", 100000), rep("ACT", 100000))
)

p_sat <- ggplot(tests |> filter(test == "SAT"), aes(x = score)) +
  geom_function(fun = dnorm, args = list(mean = sat_mean, sd = sat_sd), color = IMSCOL["black", "full"]) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = sat_mean + sat_sd * (-3:3)) +
  annotate("segment",
    x = 1800, xend = 1800, y = 0, yend = 0.001,
    color = "darkred", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = sat_mean - 4 * sat_sd, xend = sat_mean + 4 * sat_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 1800, y = 0.0011, label = "Pam", color = "darkred") +
  coord_cartesian(xlim = sat_mean + c(-1, 1) * 4 * sat_sd)

p_act <- ggplot(tests |> filter(test == "ACT"), aes(x = score)) +
  geom_function(
    fun = dnorm, args = list(mean = act_mean, sd = act_sd),
    color = IMSCOL["black", "full"]
  ) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = act_mean + act_sd * (-3:3)) +
  annotate("segment",
    x = 24, xend = 24, y = 0, yend = 0.075,
    color = "darkblue", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = act_mean - 4 * act_sd, xend = act_mean + 4 * act_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 24, y = 0.08, label = "Jim", color = "darkblue") +
  coord_cartesian(xlim = act_mean + c(-1, 1) * 4 * act_sd)

p_sat + p_act
```


## Estandarizar con el Z-Score {.medium}

Dado que no podemos simplemente comparar estos dos puntajes, en su lugar comparamos cuántas desviaciones estándar por encima de la media está cada observación.

- El puntaje de Pam es $\dfrac{1800-1500}{300}=1$ desviación estándar (SD) encima de la media 

- El puntaje de Jim es $\dfrac{24-21}{5}=0.6$ SD encima de la media




## Estandarizar con el Z-Score {.medium}

La siguiente gráfica visualiza la comparación que estamos haciendo al usar desviaciones estándar:

```{r}
#| echo: false
#| fig-asp: 0.5
#| fig-align: center

sat_mean <- 0
sat_sd <- 1
act_mean <- 0
act_sd <- 1

tests <- tibble(
  score = c(rnorm(100000, mean = sat_mean, sd = sat_sd), rnorm(100000, mean = act_mean, sd = act_sd)),
  test  = c(rep("SAT", 100000), rep("ACT", 100000))
)

p_sat <- ggplot(tests |> filter(test == "SAT"), aes(x = score)) +
  geom_function(fun = dnorm, args = list(mean = sat_mean, sd = sat_sd), color = IMSCOL["black", "full"]) +
  labs(y = NULL, x = NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),     # Removes y-axis tick marks
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_x_continuous(breaks = sat_mean + sat_sd * (-3:3)) +
  annotate("segment",
    x = 1, xend = 1, y = 0, yend = 0.3,
    color = "darkred", linetype = "dashed", size = 1
  ) +
  annotate("segment", x = sat_mean - 4 * sat_sd, xend = sat_mean + 4 * sat_sd, y = 0, yend = 0, color = IMSCOL["black", "full"]) +
  annotate("text", x = 1, y = 0.33, label = "Pam", color = "darkred") +
  annotate("segment",
    x = 0.6, xend = 0.6, y = 0, yend = 0.38,
    color = "darkblue", linetype = "dashed", size = 1
  )  +
  annotate("text", x = 0.6, y = 0.4, label = "Jim", color = "darkblue") +
  coord_cartesian(xlim = sat_mean + c(-1, 1) * 4 * sat_sd) 
p_sat
```


## El Z-score {.medium}

El Z-score de una observación representa cuántas desviaciones estándar se encuentra por encima o por debajo de la media, permitiendo comparar su posición relativa dentro de una distribución.

Si $x$ es una observación de la distribución $N(\mu,\sigma)$, el Z-score se define:

$$Z=\dfrac{x-\mu}{\sigma}$$

. . . 

Observaciones que estén más allá de $3$ SD de la media ($|Z|>3$) son usualmente consideradas inusuales.

## Maneras de detectar *Outliers* {.medium}

- $1.5 \times RIC$

- Observaciones con $|Z|>3$

- Histogramas

- Diagramas de caja

## 💪 Ejercicio 3  {.medium}

1. Completen el siguiente código que crea una variable igual a 1 si el credito está fuera del rango $1.5 \times RIC$ y 0 en caso contrario.

```{r}
#| echo: true
#| eval: false
# fivenum() devuelve: min, Q1, mediana, Q3, max
q1 <- fivenum(credit$limit_bal, na.rm = TRUE)[_]
q3 <- fivenum(________________, na.rm = TRUE)[4]
ric <- q3-q1

credit <- credit |> 
  mutate(
    # Identificar outliers por RIC
    outlier_ric = ifelse(limit_bal < (q1 - 1.5 * ___) | _________ > (q3 + 1.5 * ric), 1, 0),
  ) 
```

## 💪 Ejercicio 3  {.medium}


2. Completen el siguiente código que crea una variable igual a 1 si $|ZScore_i|>3$ y 0 en caso contrario.

```{r}
#| echo: true
#| eval: false
credit <- credit |> 
  mutate(
    z_score = (limit_bal - mean(_______, na.rm = TRUE)) / sd(_______, na.rm = TRUE),
    outlier_zscore = ifelse(abs(_______) > 3, 1, 0)
  )
```

. . .

3. Luego ejecuten el siguiente código. ¿Qué tan diferentes son los dos criterios?

```{r}
#| echo: true
#| eval: false
credit |> 
  count(outlier_zscore, outlier_ric)
```




## Distribución Normal y Probabilidad {.medium}

Si $X$ sigue una distribución normal, para encontrar probabilidades sobre $X$ se calculan áreas bajo la curva normal $N(\mu,\sigma)$

![](img/normal_prob.png){height="350" fig-align="center"}


## Calculando Probabilidades: La tabla de la Normal {.medium}

$$P(Z<{\color{orange} z})=P(Z<-0.83)=0.2033$$


![](img/normal_table.png){height="450" fig-align="center"}

## Calculando Probabilidades en R {.medium}

- Con la función `pnorm()` pueden calcular probabilidades en R:


```{r}
#| echo: true
pnorm(-0.83)
```

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 0, s = 1, L = -0.83, col = IMSCOL["blue", "full"])
```

## Calculando Probabilidades en R {.medium}

Hay dos maneras de calcular probabilidades en la parte superior de la distribución:


::::: {.columns}

:::: {.column width="50%"}

- P($Z>-0.83$) = $1$ - P($Z<-0.83$)


```{r}
#| echo: true
1 - pnorm(-0.83)
```

- Y la otra es cambiando las opciones de la función:

```{r}
#| echo: true
 pnorm(-0.83, lower.tail=FALSE)
```

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 0, s = 1, U = -0.83, col = IMSCOL["blue", "full"])
```
::::

:::::



## Calculando probabilidades para la Normal {.medium}

¿Qué porcentaje de estudiantes tiene puntajes mayores a 1630 en el SAT? Recuerden que SAT$\sim N(1500,300)$

. . .

```{r}
#| fig-align: center
#| fig-width: 7
#| fig-height: 6
#| echo: false
par(mar = c(2, 0, 0, 0))
par_og <- par(no.readonly = TRUE) # save original par
par(mar = c(0, 0, 0, 0), mfrow = c(2, 1))

normTail(m = 1500, s = 300, U = 1630, col = IMSCOL["blue", "full"])
```


## Calculando probabilidades para la Normal {.medium}
### Probabilidades con Área Complementaria


::::: {.columns}

:::: {.column width="40%"}

1. Calcular el Z-score:

$$Z=\dfrac{1630-1500}{300}=0.43$$

2. Calcular el área bajo la distribución normal estandarizada:

```{r}
#| echo: true
pnorm(0.43)
 1 - pnorm(0.43)
```




::::

:::: {.column  width="60%"}

```{r}
#| fig-align: center
#| fig-width: 7
#| fig-height: 5
#| echo: false
X <- seq(-3.2, 3.2, 0.01)
Y <- dnorm(X)
plot(X, Y, type = "l", axes = F, xlim = c(-3.4, 16 + 3.4), ylim = c(0, 0.652), xlab = NA, ylab = NA)
lines(X, rep(0, length(X)))
these <- which(X <= 8)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]), c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X, Y)
# abline(h=0)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
lines(c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
text(0, 0.45, format(c(1, 0.0001), scientific = FALSE, digits = 4)[1], cex = 1)
lines(X + 8, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 8, rep(0, length(X)))
these <- which(X <= 0.43)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8, Y)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
lines(8 + c(3, 8 - 3), c(0.23, 0.23), lwd = 3)
lines(8 + c(3, 8 - 3), c(0.17, 0.17), lwd = 3)
lines(c(3.72, 4.28), rep(0.45, 2), lwd = 2)
text(8, 0.45, format(0.6664, scientific = FALSE, digits = 4)[1], cex = 1)
lines(X + 8 + 8, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 8 + 8, rep(0, length(X)))
these <- which(X > 0.43)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8 + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8 + 8, Y)
lines(c(0, 0), dnorm(0) * c(0.01, 0.99), col = COL[6], lty = 3)
text(12, 0.45, "=", cex = 1.5)
text(16, 0.45, format(0.3336, scientific = FALSE, digits = 4)[1], cex = 1)
par(par_og) # restore original par
```

::::

:::::


## Calculando probabilidades para la Normal {.medium}
### Usando las opciones de pnorm()

::::: {.columns}

:::: {.column width="50%"}

1. Modificar los valores en la función `pnorm()`:

```{r}
#| echo: true
pnorm(1630,
      mean = 1500,
      sd = 300,
      lower.tail=FALSE)
```

::::

:::: {.column  width="50%"}

```{r}
#| echo: false
#| fig-align: center
openintro::normTail(m = 1500, s = 300, U = 1630, col = IMSCOL["blue", "full"])
```
::::

:::::




## Calculando probabilidades: Otro ejemplo {.medium}

Con base en una muestra de 100 transacciones, el gasto promedio mensual de los clientes en una tienda minorista estadounidense sigue una distribución casi normal con una media de $70.00 y una desviación estándar de $3.30. ¿Cuál es la probabilidad de seleccionar aleatoriamente una transacción entre 69 y 74 dólares?

. . .

```{r}
#| fig-asp: 0.4
#| out-width: 60%
#| fig-align: center
#| fig-width: 5
#| echo: false
par(mar = c(2, 0, 0, 0))
normTail(70, 3.3, M = c(69, 74), col = IMSCOL["blue", "full"])
```


## Calculando probabilidades: Otro ejemplo {.medium}

```{r}
#| fig-asp: 0.25
#| fig-align: center
#| out-width: 100%
#| echo: false
X <- seq(-3.2, 3.2, 0.01)
Y <- dnorm(X)
par(mar = c(2, 0, 0, 0))
plot(X, Y, type = "l", axes = F, xlim = c(-3.4, 24 + 3.4), ylim = c(0, 0.6), xlab = NA, ylab = NA)
lines(X, rep(0, length(X)))
these <- which(X <= 8)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]), c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X, Y)
lines(c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
lines(X + 8, Y, type = "l")
lines(X + 8, rep(0, length(X)))
these <- which(X < -0.303)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 8, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 8, Y)
lines(8 + c(3, 8 - 3), c(0.2, 0.2), lwd = 3)
lines(X + 16, Y, type = "l")
lines(X + 16, rep(0, length(X)))
these <- which(X > 1.212)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 16, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 16, Y)
lines(16 + c(3, 8 - 3), c(0.23, 0.23), lwd = 3)
lines(16 + c(3, 8 - 3), c(0.17, 0.17), lwd = 3)
lines(X + 24, Y, type = "l", xlim = c(-3.4, 3.4))
lines(X + 24, rep(0, length(X)))
these <- which(X > -0.303 & X < 1.212)
polygon(c(X[these[1]], X[these], X[rev(these)[1]]) + 24, c(0, Y[these], 0), col = IMSCOL["blue", "full"])
lines(X + 24, Y)
text(0, 0.53, "1.0000")
text(8, 0.53, "0.3820")
text(16, 0.53, "0.1131")
text(24, 0.53, "0.5047")
```

::::: {.columns}

:::: {.column .fragment width="50%"}

$$Z_1=\dfrac{69-70}{3.3}=-0.30$$

$$Z_2=\dfrac{74-70}{3.3}=1.21$$




::::

:::: {.column .fragment width="50%"}

```{r}
#| echo: true
a <- pnorm(-0.30)
a
b <- pnorm(1.21, lower.tail=FALSE)
b
1-a-b
```
::::

:::::


## Calculando cuartiles/percentiles {.medium}

¿Qué valor en la distribución de transacciones es el primer cuartil ($Q_1$)? Recuerden que 25% de los datos son menores al primer cuartil.

```{r}
#| fig-asp: 0.4
#| out-width: 60%
#| fig-align: center
#| fig-width: 5
#| echo: false
par(mar = c(2, 0, 0, 0))
normTail(70, 3.3, L = qnorm(0.25, 70, 3.3), col = IMSCOL["blue", "full"])
text(66.5, 0.03, "25%\n(0.25)", cex = 1, col = IMSCOL["black", "full"])
```

## Calculando cuartiles/percentiles en R {.medium}

La función `qnorm()` permite calcular cuartiles/percentiles para una distribución normal:

```{r}
#| echo: true
qnorm(0.25, mean = 0, sd = 1)
```

. . .

Sabiendo que el primer cuartil en la distribución normal estandarizada es $Z_{Q_1}=-0.674$:


$$ -0.674 = Z_{Q_1} = \frac{x_{Q_1} - \mu}{\sigma} = \frac{x_{Q_1} - 70}{3.3} $$
Resolviendo para $Z_{Q_1}$, se encuentra que 67.7 dólares es el primer cuartil en la distribución original.

## Calculando cuartiles/percentiles en R {.medium}

Al usar las opciones de la función `qnorm()`, podemos calcular el valor exacto del primer cuartil:

```{r}
#| echo: true
qnorm(0.25, mean = 70, sd = 3.3)
```

. . .

### ¿Qué es un percentil?

- Es un valor que divide un conjunto de datos ordenados en 100 partes iguales, indicando la posición relativa de un dato dentro del conjunto

- Por ejemplo, el primer cuartil es equivalente al percentil 25, lo que significa que el 25% de los datos son menores o iguales a ese valor


## La regla 68-95-99.7 {.medium}


```{r}
#| echo: false
#| fig-height: 5
#| fig-width: 8
#| fig-align: center

par(mar = c(2, 0, 0, 0))
X <- seq(-4, 4, 0.01)
Y <- dnorm(X)
plot(X, Y, type = "n", axes = F, ylim = c(0, 0.4), xlim = c(-3.2, 3.2), xlab = NA, ylab = NA)
abline(h = 0, col = IMSCOL["black", "full"])
axis(1, at = -3:3, label = expression(
  mu - 3 * sigma, mu - 2 * sigma, mu - sigma, mu,
  mu + sigma, mu + 2 * sigma, mu + 3 * sigma
))
ii <- c(1, 2, 3)
jj <- c(1, 1, 1)
for (i in 3:1) {
  these <- (X >= i - 1 & X <= i)
  polygon(c(i - 1, X[these], i), c(0, Y[these], 0), col = IMSCOL[ii[i], jj[i]], border = IMSCOL[ii[i], jj[i]])
  these <- (X >= -i & X <= -i + 1)
  polygon(c(-i, X[these], -i + 1), c(0, Y[these], 0), col = IMSCOL[ii[i], jj[i]], border = IMSCOL[ii[i], jj[i]])
}
# ===> label 99.7 <===#
arrows(-3, 0.03, 3, 0.03, code = 3, col = "#444444", length = 0.15)
text(0, 0.02, "99.7%", pos = 3)
# ===> label 95 <===#
arrows(-2, 0.13, 2, 0.13, code = 3, col = "#444444", length = 0.15)
text(0, 0.12, "95%", pos = 3)
# ===> label 68 <===#
arrows(-1, 0.23, 1, 0.23, code = 3, col = "#444444", length = 0.15)
text(0, 0.22, "68%", pos = 3)
lines(X, Y, col = "#888888")
abline(h = 0, col = "#AAAAAA")
```

. . . 

```{r}
#| echo: true
pnorm(1) - pnorm(-1)
pnorm(2) - pnorm(-2)
pnorm(3) - pnorm(-3)
```


## 💪 Ejercicio 4  {.medium}


1. Suponga que el límite de crédito `limit_bal`$\sim N(150000,50000)$. Calcule de dos maneras diferentes la probabilidad de que un cliente seleccionado al azar tenga un límite de crédito superior a 240000.

2. Encuentren el límite de crédito que corresponde al percentil 95.


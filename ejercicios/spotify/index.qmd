---
title: "An√°lisis de Datos de Spotify"

lang: es

format: 
  closeread-html:
   css: msaz.css
   code-tools: false
   fig-format: svg
   toc: true
   linkcolor: tomato
---

üìÖ **Fecha L√≠mite:** Martes 18 de febrero, 6:00 p.m.

**Formato de Entrega:** Me env√≠an el R Script al correo con el formato usual `nombre_apellido.R`. Si realizan el trabajo en parejas, nombren el archivo `nombre1_apellido1_nombre2_apellido2.R`. *Antes de enviar el archivo, aseg√∫rense de que su c√≥digo se ejecuta correctamente en un nuevo R Script limpio*.


**Criterios de evaluaci√≥n:**

‚úî C√≥digo correcto y bien estructurado: si el c√≥digo no ejecuta, descuento la mitad del punto.

‚úî Gr√°ficos generados correctamente: Uso de `ggplot2` con etiquetas claras y colores adecuados.

‚úî Interpretaci√≥n y an√°lisis: Respuesta clara a las preguntas en comentarios y que sea concisa. Si su respuesta tiene m√°s de 3 l√≠neas es **muy** larga.

‚úî Formato y organizaci√≥n: C√≥digo limpio, comentado y con t√≠tulos adecuados en el documento.


## Descripci√≥n del Dataset de Spotify

El conjunto de datos contiene informaci√≥n sobre diversas canciones disponibles en Spotify, incluyendo caracter√≠sticas musicales, metadatos del artista y medidas de popularidad. A continuaci√≥n, se detallan las principales variables:

1. **Metadatos de la canci√≥n**:

`artist`: Nombre del artista o banda.

`song`: Nombre de la canci√≥n.

`year`: A√±o de lanzamiento.

`genre`: G√©nero musical de la canci√≥n.


2. **Popularidad y m√©tricas generales**:

`popularity`: Medida de popularidad en una escala de 0 a 100, donde valores m√°s altos indican mayor popularidad.

`explicit`: Indica si la canci√≥n tiene contenido expl√≠cito (TRUE o FALSE).

`duration_ms`: Duraci√≥n de la canci√≥n en milisegundos.

3. **Caracter√≠sticas musicales**:

`danceability`: Medida de qu√© tan bailable es una canci√≥n (0 a 1).

`energy`: Nivel de intensidad y actividad de la canci√≥n (0 a 1).

`tempo`: Velocidad de la canci√≥n en beats por minuto (BPM).

`key`: La tonalidad en la que est√° la canci√≥n, representada por un n√∫mero (0 = C, 1 = C‚ôØ/D‚ô≠, 2 = D, etc.).

`mode`: Modalidad de la canci√≥n (1 = mayor, 0 = menor).

`loudness`: Volumen promedio de la canci√≥n en decibeles (dB).

4. **Otras caracter√≠sticas sonoras**:

`speechiness`: Detecta la presencia de palabras habladas en una canci√≥n (0 a 1).

`acousticness`: Indica qu√© tan ac√∫stica es una canci√≥n (0 a 1).

`instrumentalness`: Mide la probabilidad de que una canci√≥n no tenga voces (0 a 1).

`liveness`: Estima si una canci√≥n fue grabada en vivo (0 a 1).

`valence`: Mide qu√© tan positiva o feliz es una canci√≥n (0 a 1).
     
## Ejercicio 1

Abran un R Script, y utilizando la siguiente plantilla, carguen el paquete `tidyverse`. Inst√°lenlos desde la consola si es la primera vez que usan su PC actual.

```{r}
#| eval: false
#| echo: true
## ------------------------------
## An√°lisis de Spotify
##
## Autor(es): 
##
## Fecha: 
## ------------------------------

## establecemos el directorio de trabajo
## En esta carpeta deber√≠an estar los datos
setwd("C:/Users/nombre_apellido/OneDrive/Documentos/analitica_spotify/data")
   
## cargamos todos los paquetes que usaremos en la sesi√≥n:

library(tidyverse)

## ---------------------------

### Ejercicio 1

spotify <- read.csv("spotify_data.csv")
glimpse(spotify)

```

Calculen la media, mediana, desviaci√≥n est√°ndar (sd) y rango intercuart√≠lico (IQR) de la variable `popularity`. Interpreten los resultados.


## Ejercicio 2

Creen un histograma de `popularity` con un n√∫mero de barras adecuado y colores personalizados. Agreguen una l√≠nea vertical que represente la media y la mediana (para esto usen la funci√≥n `geom_vline()`).¬øQu√© nos dice el gr√°fico?


## Ejercicio 3

Creen un diagrama de caja para la variable `popularity`. ¬øLa distribuci√≥n tiene valores at√≠picos? 

## Ejercicio 4

Creen un diagrama de caja de la variable `popularity` agrupado por la variable `explicit`. Comparen la mediana de popularidad entre canciones expl√≠citas y no expl√≠citas. ¬øLas canciones expl√≠citas son generalmente m√°s o menos populares?

## Ejercicio 5

Creen un gr√°fico de dispersi√≥n con `danceability` en el eje x y `energy` en el eje y. El gr√°fico final debe tener una l√≠nea de tendencia suavizada (`geom_smooth()`) adem√°s de los puntos. Adicional a esto, calculen la correlaci√≥n entre ambas variables. ¬øLas canciones con mayor energ√≠a tienden a ser m√°s bailables?

## Ejercicio 6

Basados en la gr√°fica que resulta de ejecturar el siguiente c√≥digo y usando la funci√≥n `filter()`, seleccionen los datos para el a√±o que evidencie menor presencia de datos at√≠picos (*outliers*) en su opini√≥n. A esta nueva base de datos ll√°menla `spotify_new`.

```{r}
#| echo: true
#| eval: false
ggplot(spotify) +
  geom_histogram(aes(x=popularity)) +
  labs(x = "Popularity Score", y = "Frequency") +
  facet_wrap(~ year) + 
  theme_minimal()
```


## Ejercicio 7

Usando los datos `spotify_new`, calculen la media y la mediana de `popularity` dependiendo de si la canci√≥n es o no expl√≠cita (`explicit`). ¬øCambia su respuesta con respecto al Ejercicio 4?


## Ejercicio 8

Usando los datos `spotify_new`, creen un gr√°fico de dispersi√≥n con `popularity` en el eje x y elijan entre `loudness`, `speechiness` o `acousticness` para el eje y. ¬øQu√© relaci√≥n observan en el gr√°fico?¬øTiene sentido o va en contra de lo que ustedes habr√≠an esperado?

## Ejercicio 9

Volvamos a los datos originales `spotify` y creemos la variable `new_genre` de la siguiente manera:

```{r}
#| echo: true
#| eval: false
spotify <- spotify |>
  mutate(new_genre = case_when(
    str_detect(genre, "latin") ~ "Latin",
    str_detect(genre, "rock") ~ "Rock",
    TRUE ~ "Other"
  ))
```

El n√∫mero total de casos para las tres categor√≠as que creamos con el c√≥digo anterior es:

```{r}
#| echo: true
#| eval: false
spotify |> 
  group_by(new_genre) |> 
  count()
``` 

Grafiquen un diagrama de caja de la variable `danceability` para las tres categor√≠as de `new_genre`. ¬øTiene sentido el gr√°fico?¬øPor qu√©?

## Ejercicio 10

Usando la funci√≥n `mutate()`:

1. Conviertan la duraci√≥n de las canciones (`duration_ms`) de milisegundos a minutos y gu√°rdenla en una nueva variable llamada `duration_min`.

2. Creen una variable categ√≥rica llamada `song_length` que clasifique las canciones en:

  - "Short" si la duraci√≥n es menor a 2.5 minutos.
  
  - "Medium" si est√° entre 2.5 y 4 minutos.
  
  - "Long" si dura m√°s de 4 minutos.
  
3. Generen un gr√°fico de barras que muestre la cantidad de canciones en cada categor√≠a (`song_length`).

